/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/***/ ((module) => {

eval("const WirejsEvent = function (singleFire, o, a) {\n\n\tthis.target = o;\n\tthis.action = a;\n\tthis.subscribers = [];\n\tthis.interceptors = [];\n\tthis.fired = 0;\n\tthis.singleFire = singleFire || false;\n\tthis.args = [];\n\n\tthis.register = function (fn) {\n\t\tif (this.singleFire && this.fired > 0) {\n\t\t\tfn();\n\t\t} else {\n\t\t\tthis.subscribers.push(fn);\n\t\t}\n\t\treturn this;\n\t}; // register()\n\n\tthis.then = this.register;\n\tthis.and = this.then;\n\n\tthis.fire = function (arg1, arg2, etc) {\n\t\tthis.args = arguments;\n\t\tthis.fireWithInterception();\n\t\tthis.fired += 1;\n\t\treturn this;\n\t}; // fire()\n\n\tthis.fireOnce = function(arg1, arg2, etc) {\n\t\tthis.singleFire = true;\n\t\treturn this.fire.apply(this, arguments);\n\t}; // fireOnce()\n\n\tthis.fireWithInterception = function (i) {\n\t\tvar i = i || 0;\n\n\t\tif (typeof (this.interceptors[i]) == 'function') {\n\t\t\tvar _t = this;\n\t\t\tthis.interceptors[i]({\n\t\t\t    /* include other/all properties of _t as necessary */\n                arguments: _t.args,\n\t\t\t\tresume: function () {\n\t\t\t\t    _t.fireWithInterception(i + 1);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tthis.fired += 1;\n\t\tvar firedFns = [];\n\n\t\twhile (this.subscribers.length > 0) {\n\t\t\tvar fn = this.subscribers.pop();\n\t\t\tif (typeof(fn) !== 'function') continue;\n\t\t\tfn.apply(null, this.args);\n\t\t\tfiredFns.push(fn);\n\t\t}\n\n\t\tif (!this.singleFire) {\n\t\t\tthis.subscribers = firedFns;\n\t\t}\n\t}; // fire()\n\n\tthis.intercept = function (fn) {\n\t\tif (typeof (fn) === 'function') {\n\t\t\tthis.interceptors.push(fn);\n\t\t}\n\t}; // intercept()\n}; // WirejsEvent()\n\nconst on = function (o, a, f, sf) {\n\tvar eventName = \"__Wirejs_event_\" + a;\n\n\tvar singleFire = sf || false;\n\n\t// todo: add other enumerable types:\n\tif (o instanceof Array || o instanceof NodeList) {\n\t\tvar _o = [];\n\t\tfor (var i = 0; i < o.length; i++) {\n\t\t\tif (o instanceof Element || o instanceof Node) {\n\t\t\t\t_o.push(o[i]);\n\t\t\t}\n\t\t}\n\t\tvar registry = {\n\t\t\tcount: _o.length,\n\t\t\tfired: 0,\n\t\t\tfn: f,\n\t\t\tsingleFire: singleFire,\n\t\t\tfire: function () {\n\t\t\t\tthis.fired++;\n\t\t\t\tif (this.fired >= this.count) {\n\t\t\t\t\ton(this, 'complete').fire();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// for debugging and/or monitoring\n\t\t\tobjects: _o,\n\t\t\teventName: eventName\n\t\t};\n\n\t\tif (_o.length > 0) {\n\t\t\tfor (var i = 0; i < _o.length; i++) {\n\t\t\t\ton(_o[i], a, function () { registry.fire(); }, singleFire);\n\t\t\t}\n\t\t} else {\n\t\t\tregistry.fire();\n\t\t}\n\n\t\treturn on(registry, 'complete');\n\t}\n\n\tif (typeof (o[eventName]) === 'undefined') {\n\t\to[eventName] = new WirejsEvent(singleFire, o, eventName);\n\t}\n\n\tif (typeof(f) == 'function') {\n\t\to[eventName].register(f);\n\t}\n\n\treturn o[eventName];\n};\n\nconst onready = function (o, f) {\n\treturn on(o, 'ready', f, true);\n};\n\nconst once = function(object, name) {\n\treturn on(object, name, undefined, true);\n}\n\nconst upon = function(test, fn) {\n\tif (typeof(test) == 'function' && test()) {\n\t\tfn();\n\t} else if (typeof(test) == 'string' && window[test]) {\n\t\tfn();\n\t} else {\n\t\tsetTimeout(function() { upon(test, fn); }, 50);\n\t}\n};\n\nmodule.exports = {\n\ton, once, onready, upon\n}\n\n//# sourceURL=webpack://wirejs-events/./lib/index.js?");

/***/ }),

/***/ "./node_modules/qunit/qunit/qunit.js":
/*!*******************************************!*\
  !*** ./node_modules/qunit/qunit/qunit.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * QUnit 2.19.1\n * https://qunitjs.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n */\n(function () {\n  'use strict';\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n      writable: false\n    });\n    return Constructor;\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n\n    var _s, _e;\n\n    try {\n      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n    if (!it) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n\n        var F = function () {};\n\n        return {\n          s: F,\n          n: function () {\n            if (i >= o.length) return {\n              done: true\n            };\n            return {\n              done: false,\n              value: o[i++]\n            };\n          },\n          e: function (e) {\n            throw e;\n          },\n          f: F\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true,\n        didErr = false,\n        err;\n    return {\n      s: function () {\n        it = it.call(o);\n      },\n      n: function () {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function (e) {\n        didErr = true;\n        err = e;\n      },\n      f: function () {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n\n  // We don't use global-this-polyfill [1], because it modifies\n  // the globals scope by default. QUnit must not affect the host context\n  // as developers may test their project may be such a polyfill, and/or\n  // they may intentionally test their project with and without certain\n  // polyfills and we must not affect that. It also uses an obscure\n  // mechanism that seems to sometimes causes a runtime error in older\n  // browsers (specifically Safari and IE versions that support\n  // Object.defineProperty but then report _T_ as undefined).\n  // [1] https://github.com/ungap/global-this/blob/v0.4.4/esm/index.js\n  //\n  // Another way is `Function('return this')()`, but doing so relies\n  // on eval which will cause a CSP error on some servers.\n  //\n  // Instead, simply check the four options that already exist\n  // in all supported environments.\n  function getGlobalThis() {\n    if (typeof globalThis !== 'undefined') {\n      // For SpiderMonkey, modern browsers, and recent Node.js\n      // eslint-disable-next-line no-undef\n      return globalThis;\n    }\n\n    if (typeof self !== 'undefined') {\n      // For web workers\n      // eslint-disable-next-line no-undef\n      return self;\n    }\n\n    if (typeof window$1 !== 'undefined') {\n      // For document context in browsers\n      return window$1;\n    }\n\n    if (typeof __webpack_require__.g !== 'undefined') {\n      // For Node.js\n      // eslint-disable-next-line no-undef\n      return __webpack_require__.g;\n    }\n\n    throw new Error('Unable to locate global object');\n  } // This avoids a simple `export const` assignment as that would lead Rollup\n  // to change getGlobalThis and use the same (generated) variable name there.\n\n\n  var g = getGlobalThis();\n  var window$1 = g.window;\n  var console$1 = g.console;\n  var setTimeout$1 = g.setTimeout;\n  var clearTimeout = g.clearTimeout;\n  var document = window$1 && window$1.document;\n  var navigator = window$1 && window$1.navigator;\n  var localSessionStorage = function () {\n    var x = 'qunit-test-string';\n\n    try {\n      g.sessionStorage.setItem(x, x);\n      g.sessionStorage.removeItem(x);\n      return g.sessionStorage;\n    } catch (e) {\n      return undefined;\n    }\n  }(); // Basic fallback for ES6 Map\n  // Support: IE 9-10, Safari 7, PhantomJS; Map is undefined\n  // Support: iOS 8; `new Map(iterable)` is not supported\n  //\n  // Fallback for ES7 Map#keys\n  // Support: IE 11; Map#keys is undefined\n\n  var StringMap = typeof g.Map === 'function' && typeof g.Map.prototype.keys === 'function' && typeof g.Symbol === 'function' && _typeof(g.Symbol.iterator) === 'symbol' ? g.Map : function StringMap(input) {\n    var _this = this;\n\n    var store = Object.create(null);\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    this.has = function (strKey) {\n      return hasOwn.call(store, strKey);\n    };\n\n    this.get = function (strKey) {\n      return store[strKey];\n    };\n\n    this.set = function (strKey, val) {\n      if (!hasOwn.call(store, strKey)) {\n        this.size++;\n      }\n\n      store[strKey] = val;\n      return this;\n    };\n\n    this.delete = function (strKey) {\n      if (hasOwn.call(store, strKey)) {\n        delete store[strKey];\n        this.size--;\n      }\n    };\n\n    this.forEach = function (callback) {\n      for (var strKey in store) {\n        callback(store[strKey], strKey);\n      }\n    };\n\n    this.keys = function () {\n      return Object.keys(store);\n    };\n\n    this.clear = function () {\n      store = Object.create(null);\n      this.size = 0;\n    };\n\n    this.size = 0;\n\n    if (input) {\n      input.forEach(function (val, strKey) {\n        _this.set(strKey, val);\n      });\n    }\n  };\n\n  // Detect if the console object exists and no-op otherwise.\n  // This allows support for IE 9, which doesn't have a console\n  // object if the developer tools are not open.\n  // Support: IE 9\n  // Function#bind is supported, but no console.log.bind().\n  // Support: SpiderMonkey (mozjs 68+)\n  // The console object has a log method, but no warn method.\n\n  var Logger = {\n    warn: console$1 ? Function.prototype.bind.call(console$1.warn || console$1.log, console$1) : function () {}\n  };\n\n  var toString = Object.prototype.toString;\n  var hasOwn$1 = Object.prototype.hasOwnProperty;\n  var nativePerf = getNativePerf(); // TODO: Consider using globalThis instead so that perf marks work\n  // in Node.js as well. As they can have overhead, we should also\n  // have a way to disable these, and/or make them an opt-in reporter\n  // in QUnit 3 and then support globalThis.\n  // For example: `QUnit.addReporter(QUnit.reporters.perf)`.\n\n  function getNativePerf() {\n    if (window$1 && typeof window$1.performance !== 'undefined' && typeof window$1.performance.mark === 'function' && typeof window$1.performance.measure === 'function') {\n      return window$1.performance;\n    } else {\n      return undefined;\n    }\n  }\n\n  var performance = {\n    now: nativePerf ? nativePerf.now.bind(nativePerf) : Date.now,\n    measure: nativePerf ? function (comment, startMark, endMark) {\n      // `performance.measure` may fail if the mark could not be found.\n      // reasons a specific mark could not be found include: outside code invoking `performance.clearMarks()`\n      try {\n        nativePerf.measure(comment, startMark, endMark);\n      } catch (ex) {\n        Logger.warn('performance.measure could not be executed because of ', ex.message);\n      }\n    } : function () {},\n    mark: nativePerf ? nativePerf.mark.bind(nativePerf) : function () {}\n  }; // Returns a new Array with the elements that are in a but not in b\n\n  function diff(a, b) {\n    var result = a.slice();\n\n    for (var i = 0; i < result.length; i++) {\n      for (var j = 0; j < b.length; j++) {\n        if (result[i] === b[j]) {\n          result.splice(i, 1);\n          i--;\n          break;\n        }\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Determines whether an element exists in a given array or not.\n   *\n   * @method inArray\n   * @param {any} elem\n   * @param {Array} array\n   * @return {boolean}\n   */\n\n  function inArray(elem, array) {\n    return array.indexOf(elem) !== -1;\n  }\n  /**\n   * Recursively clone an object into a plain array or object, taking only the\n   * own enumerable properties.\n   *\n   * @param {any} obj\n   * @param {bool} [allowArray=true]\n   * @return {Object|Array}\n   */\n\n  function objectValues(obj) {\n    var allowArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var vals = allowArray && is('array', obj) ? [] : {};\n\n    for (var key in obj) {\n      if (hasOwn$1.call(obj, key)) {\n        var val = obj[key];\n        vals[key] = val === Object(val) ? objectValues(val, allowArray) : val;\n      }\n    }\n\n    return vals;\n  }\n  /**\n   * Recursively clone an object into a plain object, taking only the\n   * subset of own enumerable properties that exist a given model.\n   *\n   * @param {any} obj\n   * @param {any} model\n   * @return {Object}\n   */\n\n  function objectValuesSubset(obj, model) {\n    // Return primitive values unchanged to avoid false positives or confusing\n    // results from assert.propContains().\n    // E.g. an actual null or false wrongly equaling an empty object,\n    // or an actual string being reported as object not matching a partial object.\n    if (obj !== Object(obj)) {\n      return obj;\n    } // Unlike objectValues(), subset arrays to a plain objects as well.\n    // This enables subsetting [20, 30] with {1: 30}.\n\n\n    var subset = {};\n\n    for (var key in model) {\n      if (hasOwn$1.call(model, key) && hasOwn$1.call(obj, key)) {\n        subset[key] = objectValuesSubset(obj[key], model[key]);\n      }\n    }\n\n    return subset;\n  }\n  function extend(a, b, undefOnly) {\n    for (var prop in b) {\n      if (hasOwn$1.call(b, prop)) {\n        if (b[prop] === undefined) {\n          delete a[prop];\n        } else if (!(undefOnly && typeof a[prop] !== 'undefined')) {\n          a[prop] = b[prop];\n        }\n      }\n    }\n\n    return a;\n  }\n  function objectType(obj) {\n    if (typeof obj === 'undefined') {\n      return 'undefined';\n    } // Consider: typeof null === object\n\n\n    if (obj === null) {\n      return 'null';\n    }\n\n    var match = toString.call(obj).match(/^\\[object\\s(.*)\\]$/);\n    var type = match && match[1];\n\n    switch (type) {\n      case 'Number':\n        if (isNaN(obj)) {\n          return 'nan';\n        }\n\n        return 'number';\n\n      case 'String':\n      case 'Boolean':\n      case 'Array':\n      case 'Set':\n      case 'Map':\n      case 'Date':\n      case 'RegExp':\n      case 'Function':\n      case 'Symbol':\n        return type.toLowerCase();\n\n      default:\n        return _typeof(obj);\n    }\n  } // Safe object type checking\n\n  function is(type, obj) {\n    return objectType(obj) === type;\n  } // Based on Java's String.hashCode, a simple but not\n  // rigorously collision resistant hashing function\n\n  function generateHash(module, testName) {\n    var str = module + '\\x1C' + testName;\n    var hash = 0;\n\n    for (var i = 0; i < str.length; i++) {\n      hash = (hash << 5) - hash + str.charCodeAt(i);\n      hash |= 0;\n    } // Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n    // strictly necessary but increases user understanding that the id is a SHA-like hash\n\n\n    var hex = (0x100000000 + hash).toString(16);\n\n    if (hex.length < 8) {\n      hex = '0000000' + hex;\n    }\n\n    return hex.slice(-8);\n  }\n  /**\n   * Converts an error into a simple string for comparisons.\n   *\n   * @param {Error|any} error\n   * @return {string}\n   */\n\n  function errorString(error) {\n    // Use String() instead of toString() to handle non-object values like undefined or null.\n    var resultErrorString = String(error); // If the error wasn't a subclass of Error but something like\n    // an object literal with name and message properties...\n\n    if (resultErrorString.slice(0, 7) === '[object') {\n      // Based on https://es5.github.io/#x15.11.4.4\n      return (error.name || 'Error') + (error.message ? \": \".concat(error.message) : '');\n    } else {\n      return resultErrorString;\n    }\n  }\n\n  // Authors: Philippe Rathé <prathe@gmail.com>, David Chan <david@troi.org>\n\n  var equiv = (function () {\n    // Value pairs queued for comparison. Used for breadth-first processing order, recursion\n    // detection and avoiding repeated comparison (see below for details).\n    // Elements are { a: val, b: val }.\n    var pairs = [];\n\n    function useStrictEquality(a, b) {\n      // This only gets called if a and b are not strict equal, and is used to compare on\n      // the primitive values inside object wrappers. For example:\n      // `var i = 1;`\n      // `var j = new Number(1);`\n      // Neither a nor b can be null, as a !== b and they have the same type.\n      if (_typeof(a) === 'object') {\n        a = a.valueOf();\n      }\n\n      if (_typeof(b) === 'object') {\n        b = b.valueOf();\n      }\n\n      return a === b;\n    }\n\n    function compareConstructors(a, b) {\n      var protoA = Object.getPrototypeOf(a);\n      var protoB = Object.getPrototypeOf(b); // Comparing constructors is more strict than using `instanceof`\n\n      if (a.constructor === b.constructor) {\n        return true;\n      } // Ref #851\n      // If the obj prototype descends from a null constructor, treat it\n      // as a null prototype.\n\n\n      if (protoA && protoA.constructor === null) {\n        protoA = null;\n      }\n\n      if (protoB && protoB.constructor === null) {\n        protoB = null;\n      } // Allow objects with no prototype to be equivalent to\n      // objects with Object as their constructor.\n\n\n      if (protoA === null && protoB === Object.prototype || protoB === null && protoA === Object.prototype) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function getRegExpFlags(regexp) {\n      return 'flags' in regexp ? regexp.flags : regexp.toString().match(/[gimuy]*$/)[0];\n    }\n\n    function isContainer(val) {\n      return ['object', 'array', 'map', 'set'].indexOf(objectType(val)) !== -1;\n    }\n\n    function breadthFirstCompareChild(a, b) {\n      // If a is a container not reference-equal to b, postpone the comparison to the\n      // end of the pairs queue -- unless (a, b) has been seen before, in which case skip\n      // over the pair.\n      if (a === b) {\n        return true;\n      }\n\n      if (!isContainer(a)) {\n        return typeEquiv(a, b);\n      }\n\n      if (pairs.every(function (pair) {\n        return pair.a !== a || pair.b !== b;\n      })) {\n        // Not yet started comparing this pair\n        pairs.push({\n          a: a,\n          b: b\n        });\n      }\n\n      return true;\n    }\n\n    var callbacks = {\n      string: useStrictEquality,\n      boolean: useStrictEquality,\n      number: useStrictEquality,\n      null: useStrictEquality,\n      undefined: useStrictEquality,\n      symbol: useStrictEquality,\n      date: useStrictEquality,\n      nan: function nan() {\n        return true;\n      },\n      regexp: function regexp(a, b) {\n        return a.source === b.source && // Include flags in the comparison\n        getRegExpFlags(a) === getRegExpFlags(b);\n      },\n      // abort (identical references / instance methods were skipped earlier)\n      function: function _function() {\n        return false;\n      },\n      array: function array(a, b) {\n        var len = a.length;\n\n        if (len !== b.length) {\n          // Safe and faster\n          return false;\n        }\n\n        for (var i = 0; i < len; i++) {\n          // Compare non-containers; queue non-reference-equal containers\n          if (!breadthFirstCompareChild(a[i], b[i])) {\n            return false;\n          }\n        }\n\n        return true;\n      },\n      // Define sets a and b to be equivalent if for each element aVal in a, there\n      // is some element bVal in b such that aVal and bVal are equivalent. Element\n      // repetitions are not counted, so these are equivalent:\n      // a = new Set( [ {}, [], [] ] );\n      // b = new Set( [ {}, {}, [] ] );\n      set: function set(a, b) {\n        if (a.size !== b.size) {\n          // This optimization has certain quirks because of the lack of\n          // repetition counting. For instance, adding the same\n          // (reference-identical) element to two equivalent sets can\n          // make them non-equivalent.\n          return false;\n        }\n\n        var outerEq = true;\n        a.forEach(function (aVal) {\n          // Short-circuit if the result is already known. (Using for...of\n          // with a break clause would be cleaner here, but it would cause\n          // a syntax error on older JavaScript implementations even if\n          // Set is unused)\n          if (!outerEq) {\n            return;\n          }\n\n          var innerEq = false;\n          b.forEach(function (bVal) {\n            // Likewise, short-circuit if the result is already known\n            if (innerEq) {\n              return;\n            } // Swap out the global pairs list, as the nested call to\n            // innerEquiv will clobber its contents\n\n\n            var parentPairs = pairs;\n\n            if (innerEquiv(bVal, aVal)) {\n              innerEq = true;\n            } // Replace the global pairs list\n\n\n            pairs = parentPairs;\n          });\n\n          if (!innerEq) {\n            outerEq = false;\n          }\n        });\n        return outerEq;\n      },\n      // Define maps a and b to be equivalent if for each key-value pair (aKey, aVal)\n      // in a, there is some key-value pair (bKey, bVal) in b such that\n      // [ aKey, aVal ] and [ bKey, bVal ] are equivalent. Key repetitions are not\n      // counted, so these are equivalent:\n      // a = new Map( [ [ {}, 1 ], [ {}, 1 ], [ [], 1 ] ] );\n      // b = new Map( [ [ {}, 1 ], [ [], 1 ], [ [], 1 ] ] );\n      map: function map(a, b) {\n        if (a.size !== b.size) {\n          // This optimization has certain quirks because of the lack of\n          // repetition counting. For instance, adding the same\n          // (reference-identical) key-value pair to two equivalent maps\n          // can make them non-equivalent.\n          return false;\n        }\n\n        var outerEq = true;\n        a.forEach(function (aVal, aKey) {\n          // Short-circuit if the result is already known. (Using for...of\n          // with a break clause would be cleaner here, but it would cause\n          // a syntax error on older JavaScript implementations even if\n          // Map is unused)\n          if (!outerEq) {\n            return;\n          }\n\n          var innerEq = false;\n          b.forEach(function (bVal, bKey) {\n            // Likewise, short-circuit if the result is already known\n            if (innerEq) {\n              return;\n            } // Swap out the global pairs list, as the nested call to\n            // innerEquiv will clobber its contents\n\n\n            var parentPairs = pairs;\n\n            if (innerEquiv([bVal, bKey], [aVal, aKey])) {\n              innerEq = true;\n            } // Replace the global pairs list\n\n\n            pairs = parentPairs;\n          });\n\n          if (!innerEq) {\n            outerEq = false;\n          }\n        });\n        return outerEq;\n      },\n      object: function object(a, b) {\n        if (compareConstructors(a, b) === false) {\n          return false;\n        }\n\n        var aProperties = [];\n        var bProperties = []; // Be strict: don't ensure hasOwnProperty and go deep\n\n        for (var i in a) {\n          // Collect a's properties\n          aProperties.push(i); // Skip OOP methods that look the same\n\n          if (a.constructor !== Object && typeof a.constructor !== 'undefined' && typeof a[i] === 'function' && typeof b[i] === 'function' && a[i].toString() === b[i].toString()) {\n            continue;\n          } // Compare non-containers; queue non-reference-equal containers\n\n\n          if (!breadthFirstCompareChild(a[i], b[i])) {\n            return false;\n          }\n        }\n\n        for (var _i in b) {\n          // Collect b's properties\n          bProperties.push(_i);\n        } // Ensures identical properties name\n\n\n        return typeEquiv(aProperties.sort(), bProperties.sort());\n      }\n    };\n\n    function typeEquiv(a, b) {\n      var type = objectType(a); // Callbacks for containers will append to the pairs queue to achieve breadth-first\n      // search order. The pairs queue is also used to avoid reprocessing any pair of\n      // containers that are reference-equal to a previously visited pair (a special case\n      // this being recursion detection).\n      //\n      // Because of this approach, once typeEquiv returns a false value, it should not be\n      // called again without clearing the pair queue else it may wrongly report a visited\n      // pair as being equivalent.\n\n      return objectType(b) === type && callbacks[type](a, b);\n    }\n\n    function innerEquiv(a, b) {\n      // We're done when there's nothing more to compare\n      if (arguments.length < 2) {\n        return true;\n      } // Clear the global pair queue and add the top-level values being compared\n\n\n      pairs = [{\n        a: a,\n        b: b\n      }];\n\n      for (var i = 0; i < pairs.length; i++) {\n        var pair = pairs[i]; // Perform type-specific comparison on any pairs that are not strictly\n        // equal. For container types, that comparison will postpone comparison\n        // of any sub-container pair to the end of the pair queue. This gives\n        // breadth-first search order. It also avoids the reprocessing of\n        // reference-equal siblings, cousins etc, which can have a significant speed\n        // impact when comparing a container of small objects each of which has a\n        // reference to the same (singleton) large object.\n\n        if (pair.a !== pair.b && !typeEquiv(pair.a, pair.b)) {\n          return false;\n        }\n      } // ...across all consecutive argument pairs\n\n\n      return arguments.length === 2 || innerEquiv.apply(this, [].slice.call(arguments, 1));\n    }\n\n    return function () {\n      var result = innerEquiv.apply(void 0, arguments); // Release any retained objects\n\n      pairs.length = 0;\n      return result;\n    };\n  })();\n\n  /**\n   * Config object: Maintain internal state\n   * Later exposed as QUnit.config\n   * `config` initialized at top of scope\n   */\n\n  var config = {\n    // HTML Reporter: Modify document.title when suite is done\n    altertitle: true,\n    // HTML Reporter: collapse every test except the first failing test\n    // If false, all failing tests will be expanded\n    collapse: true,\n    // whether or not to fail when there are zero tests\n    // defaults to `true`\n    failOnZeroTests: true,\n    // Select by pattern or case-insenstive substring match against \"moduleName: testName\"\n    filter: undefined,\n    // Depth up-to which object will be dumped\n    maxDepth: 5,\n    // Select case-insensitive match of the module name\n    module: undefined,\n    // HTML Reporter: Select module/test by array of internal IDs\n    moduleId: undefined,\n    // By default, run previously failed tests first\n    // very useful in combination with \"Hide passed tests\" checked\n    reorder: true,\n    // When enabled, all tests must call expect()\n    requireExpects: false,\n    // By default, scroll to top of the page when suite is done\n    scrolltop: true,\n    // The storage module to use for reordering tests\n    storage: localSessionStorage,\n    testId: undefined,\n    // HTML Reporter: List of URL parameters that are given visual controls\n    urlConfig: [],\n    // Internal: The first unnamed module\n    //\n    // By being defined as the intial value for currentModule, it is the\n    // receptacle and implied parent for any global tests. It is as if we\n    // called `QUnit.module( \"\" );` before any other tests were defined.\n    //\n    // If we reach begin() and no tests were put in it, we dequeue it as if it\n    // never existed, and in that case never expose it to the events and\n    // callbacks API.\n    //\n    // When global tests are defined, then this unnamed module will execute\n    // as any other module, including moduleStart/moduleDone events etc.\n    //\n    // Since this module isn't explicitly created by the user, they have no\n    // access to add hooks for it. The hooks object is defined to comply\n    // with internal expectations of test.js, but they will be empty.\n    // To apply hooks, place tests explicitly in a QUnit.module(), and use\n    // its hooks accordingly.\n    //\n    // For global hooks that apply to all tests and all modules, use QUnit.hooks.\n    //\n    // NOTE: This is *not* a \"global module\". It is not an ancestor of all modules\n    // and tests. It is merely the parent for any tests defined globally,\n    // before the first QUnit.module(). As such, the events for this unnamed\n    // module will fire as normal, right after its last test, and *not* at\n    // the end of the test run.\n    //\n    // NOTE: This also should probably also not become a global module, unless\n    // we keep it out of the public API. For example, it would likely not\n    // improve the user interface and plugin behaviour if all modules became\n    // wrapped between the start and end events of this module, and thus\n    // needlessly add indentation, indirection, or other visible noise.\n    // Unit tests for the callbacks API would detect that as a regression.\n    currentModule: {\n      name: '',\n      tests: [],\n      childModules: [],\n      testsRun: 0,\n      testsIgnored: 0,\n      hooks: {\n        before: [],\n        beforeEach: [],\n        afterEach: [],\n        after: []\n      }\n    },\n    // Internal: Exposed to make resets easier\n    // Ref https://github.com/qunitjs/qunit/pull/1598\n    globalHooks: {},\n    // Internal state\n    blocking: true,\n    callbacks: {},\n    modules: [],\n    queue: [],\n    stats: {\n      all: 0,\n      bad: 0,\n      testCount: 0\n    }\n  }; // Apply a predefined QUnit.config object\n  //\n  // Ignore QUnit.config if it is a QUnit distribution instead of preconfig.\n  // That means QUnit was loaded twice! (Use the same approach as export.js)\n\n  var preConfig = g && g.QUnit && !g.QUnit.version && g.QUnit.config;\n\n  if (preConfig) {\n    extend(config, preConfig);\n  } // Push a loose unnamed module to the modules collection\n\n\n  config.modules.push(config.currentModule);\n\n  var dump = (function () {\n    function quote(str) {\n      return '\"' + str.toString().replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"') + '\"';\n    }\n\n    function literal(o) {\n      return o + '';\n    }\n\n    function join(pre, arr, post) {\n      var s = dump.separator();\n      var inner = dump.indent(1);\n\n      if (arr.join) {\n        arr = arr.join(',' + s + inner);\n      }\n\n      if (!arr) {\n        return pre + post;\n      }\n\n      var base = dump.indent();\n      return [pre, inner + arr, base + post].join(s);\n    }\n\n    function array(arr, stack) {\n      if (dump.maxDepth && dump.depth > dump.maxDepth) {\n        return '[object Array]';\n      }\n\n      this.up();\n      var i = arr.length;\n      var ret = new Array(i);\n\n      while (i--) {\n        ret[i] = this.parse(arr[i], undefined, stack);\n      }\n\n      this.down();\n      return join('[', ret, ']');\n    }\n\n    function isArray(obj) {\n      return (// Native Arrays\n        toString.call(obj) === '[object Array]' || // NodeList objects\n        typeof obj.length === 'number' && obj.item !== undefined && (obj.length ? obj.item(0) === obj[0] : obj.item(0) === null && obj[0] === undefined)\n      );\n    }\n\n    var reName = /^function (\\w+)/;\n    var dump = {\n      // The objType is used mostly internally, you can fix a (custom) type in advance\n      parse: function parse(obj, objType, stack) {\n        stack = stack || [];\n        var objIndex = stack.indexOf(obj);\n\n        if (objIndex !== -1) {\n          return \"recursion(\".concat(objIndex - stack.length, \")\");\n        }\n\n        objType = objType || this.typeOf(obj);\n        var parser = this.parsers[objType];\n\n        var parserType = _typeof(parser);\n\n        if (parserType === 'function') {\n          stack.push(obj);\n          var res = parser.call(this, obj, stack);\n          stack.pop();\n          return res;\n        }\n\n        if (parserType === 'string') {\n          return parser;\n        }\n\n        return '[ERROR: Missing QUnit.dump formatter for type ' + objType + ']';\n      },\n      typeOf: function typeOf(obj) {\n        var type;\n\n        if (obj === null) {\n          type = 'null';\n        } else if (typeof obj === 'undefined') {\n          type = 'undefined';\n        } else if (is('regexp', obj)) {\n          type = 'regexp';\n        } else if (is('date', obj)) {\n          type = 'date';\n        } else if (is('function', obj)) {\n          type = 'function';\n        } else if (obj.setInterval !== undefined && obj.document !== undefined && obj.nodeType === undefined) {\n          type = 'window';\n        } else if (obj.nodeType === 9) {\n          type = 'document';\n        } else if (obj.nodeType) {\n          type = 'node';\n        } else if (isArray(obj)) {\n          type = 'array';\n        } else if (obj.constructor === Error.prototype.constructor) {\n          type = 'error';\n        } else {\n          type = _typeof(obj);\n        }\n\n        return type;\n      },\n      separator: function separator() {\n        if (this.multiline) {\n          return this.HTML ? '<br />' : '\\n';\n        } else {\n          return this.HTML ? '&#160;' : ' ';\n        }\n      },\n      // Extra can be a number, shortcut for increasing-calling-decreasing\n      indent: function indent(extra) {\n        if (!this.multiline) {\n          return '';\n        }\n\n        var chr = this.indentChar;\n\n        if (this.HTML) {\n          chr = chr.replace(/\\t/g, '   ').replace(/ /g, '&#160;');\n        }\n\n        return new Array(this.depth + (extra || 0)).join(chr);\n      },\n      up: function up(a) {\n        this.depth += a || 1;\n      },\n      down: function down(a) {\n        this.depth -= a || 1;\n      },\n      setParser: function setParser(name, parser) {\n        this.parsers[name] = parser;\n      },\n      // The next 3 are exposed so you can use them\n      quote: quote,\n      literal: literal,\n      join: join,\n      depth: 1,\n      maxDepth: config.maxDepth,\n      // This is the list of parsers, to modify them, use dump.setParser\n      parsers: {\n        window: '[Window]',\n        document: '[Document]',\n        error: function error(_error) {\n          return 'Error(\"' + _error.message + '\")';\n        },\n        // This has been unused since QUnit 1.0.0.\n        // @todo Deprecate and remove.\n        unknown: '[Unknown]',\n        null: 'null',\n        undefined: 'undefined',\n        function: function _function(fn) {\n          var ret = 'function'; // Functions never have name in IE\n\n          var name = 'name' in fn ? fn.name : (reName.exec(fn) || [])[1];\n\n          if (name) {\n            ret += ' ' + name;\n          }\n\n          ret += '(';\n          ret = [ret, dump.parse(fn, 'functionArgs'), '){'].join('');\n          return join(ret, dump.parse(fn, 'functionCode'), '}');\n        },\n        array: array,\n        nodelist: array,\n        arguments: array,\n        object: function object(map, stack) {\n          var ret = [];\n\n          if (dump.maxDepth && dump.depth > dump.maxDepth) {\n            return '[object Object]';\n          }\n\n          dump.up();\n          var keys = [];\n\n          for (var key in map) {\n            keys.push(key);\n          } // Some properties are not always enumerable on Error objects.\n\n\n          var nonEnumerableProperties = ['message', 'name'];\n\n          for (var i in nonEnumerableProperties) {\n            var _key = nonEnumerableProperties[i];\n\n            if (_key in map && !inArray(_key, keys)) {\n              keys.push(_key);\n            }\n          }\n\n          keys.sort();\n\n          for (var _i = 0; _i < keys.length; _i++) {\n            var _key2 = keys[_i];\n            var val = map[_key2];\n            ret.push(dump.parse(_key2, 'key') + ': ' + dump.parse(val, undefined, stack));\n          }\n\n          dump.down();\n          return join('{', ret, '}');\n        },\n        node: function node(_node) {\n          var open = dump.HTML ? '&lt;' : '<';\n          var close = dump.HTML ? '&gt;' : '>';\n\n          var tag = _node.nodeName.toLowerCase();\n\n          var ret = open + tag;\n          var attrs = _node.attributes;\n\n          if (attrs) {\n            for (var i = 0; i < attrs.length; i++) {\n              var val = attrs[i].nodeValue; // IE6 includes all attributes in .attributes, even ones not explicitly\n              // set. Those have values like undefined, null, 0, false, \"\" or\n              // \"inherit\".\n\n              if (val && val !== 'inherit') {\n                ret += ' ' + attrs[i].nodeName + '=' + dump.parse(val, 'attribute');\n              }\n            }\n          }\n\n          ret += close; // Show content of TextNode or CDATASection\n\n          if (_node.nodeType === 3 || _node.nodeType === 4) {\n            ret += _node.nodeValue;\n          }\n\n          return ret + open + '/' + tag + close;\n        },\n        // Function calls it internally, it's the arguments part of the function\n        functionArgs: function functionArgs(fn) {\n          var l = fn.length;\n\n          if (!l) {\n            return '';\n          }\n\n          var args = new Array(l);\n\n          while (l--) {\n            // 97 is 'a'\n            args[l] = String.fromCharCode(97 + l);\n          }\n\n          return ' ' + args.join(', ') + ' ';\n        },\n        // Object calls it internally, the key part of an item in a map\n        key: quote,\n        // Function calls it internally, it's the content of the function\n        functionCode: '[code]',\n        // Node calls it internally, it's a html attribute value\n        attribute: quote,\n        string: quote,\n        date: quote,\n        regexp: literal,\n        number: literal,\n        boolean: literal,\n        symbol: function symbol(sym) {\n          return sym.toString();\n        }\n      },\n      // If true, entities are escaped ( <, >, \\t, space and \\n )\n      HTML: false,\n      // Indentation unit\n      indentChar: '  ',\n      // If true, items in a collection, are separated by a \\n, else just a space.\n      multiline: true\n    };\n    return dump;\n  })();\n\n  var SuiteReport = /*#__PURE__*/function () {\n    function SuiteReport(name, parentSuite) {\n      _classCallCheck(this, SuiteReport);\n\n      this.name = name;\n      this.fullName = parentSuite ? parentSuite.fullName.concat(name) : []; // When an \"error\" event is emitted from onUncaughtException(), the\n      // \"runEnd\" event should report the status as failed. The \"runEnd\" event data\n      // is tracked through this property (via the \"runSuite\" instance).\n\n      this.globalFailureCount = 0;\n      this.tests = [];\n      this.childSuites = [];\n\n      if (parentSuite) {\n        parentSuite.pushChildSuite(this);\n      }\n    }\n\n    _createClass(SuiteReport, [{\n      key: \"start\",\n      value: function start(recordTime) {\n        if (recordTime) {\n          this._startTime = performance.now();\n          var suiteLevel = this.fullName.length;\n          performance.mark(\"qunit_suite_\".concat(suiteLevel, \"_start\"));\n        }\n\n        return {\n          name: this.name,\n          fullName: this.fullName.slice(),\n          tests: this.tests.map(function (test) {\n            return test.start();\n          }),\n          childSuites: this.childSuites.map(function (suite) {\n            return suite.start();\n          }),\n          testCounts: {\n            total: this.getTestCounts().total\n          }\n        };\n      }\n    }, {\n      key: \"end\",\n      value: function end(recordTime) {\n        if (recordTime) {\n          this._endTime = performance.now();\n          var suiteLevel = this.fullName.length;\n          var suiteName = this.fullName.join(' – ');\n          performance.mark(\"qunit_suite_\".concat(suiteLevel, \"_end\"));\n          performance.measure(suiteLevel === 0 ? 'QUnit Test Run' : \"QUnit Test Suite: \".concat(suiteName), \"qunit_suite_\".concat(suiteLevel, \"_start\"), \"qunit_suite_\".concat(suiteLevel, \"_end\"));\n        }\n\n        return {\n          name: this.name,\n          fullName: this.fullName.slice(),\n          tests: this.tests.map(function (test) {\n            return test.end();\n          }),\n          childSuites: this.childSuites.map(function (suite) {\n            return suite.end();\n          }),\n          testCounts: this.getTestCounts(),\n          runtime: this.getRuntime(),\n          status: this.getStatus()\n        };\n      }\n    }, {\n      key: \"pushChildSuite\",\n      value: function pushChildSuite(suite) {\n        this.childSuites.push(suite);\n      }\n    }, {\n      key: \"pushTest\",\n      value: function pushTest(test) {\n        this.tests.push(test);\n      }\n    }, {\n      key: \"getRuntime\",\n      value: function getRuntime() {\n        return Math.round(this._endTime - this._startTime);\n      }\n    }, {\n      key: \"getTestCounts\",\n      value: function getTestCounts() {\n        var counts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n          passed: 0,\n          failed: 0,\n          skipped: 0,\n          todo: 0,\n          total: 0\n        };\n        counts.failed += this.globalFailureCount;\n        counts.total += this.globalFailureCount;\n        counts = this.tests.reduce(function (counts, test) {\n          if (test.valid) {\n            counts[test.getStatus()]++;\n            counts.total++;\n          }\n\n          return counts;\n        }, counts);\n        return this.childSuites.reduce(function (counts, suite) {\n          return suite.getTestCounts(counts);\n        }, counts);\n      }\n    }, {\n      key: \"getStatus\",\n      value: function getStatus() {\n        var _this$getTestCounts = this.getTestCounts(),\n            total = _this$getTestCounts.total,\n            failed = _this$getTestCounts.failed,\n            skipped = _this$getTestCounts.skipped,\n            todo = _this$getTestCounts.todo;\n\n        if (failed) {\n          return 'failed';\n        } else {\n          if (skipped === total) {\n            return 'skipped';\n          } else if (todo === total) {\n            return 'todo';\n          } else {\n            return 'passed';\n          }\n        }\n      }\n    }]);\n\n    return SuiteReport;\n  }();\n\n  var moduleStack = [];\n  var runSuite = new SuiteReport();\n\n  function isParentModuleInQueue() {\n    var modulesInQueue = config.modules.filter(function (module) {\n      return !module.ignored;\n    }).map(function (module) {\n      return module.moduleId;\n    });\n    return moduleStack.some(function (module) {\n      return modulesInQueue.includes(module.moduleId);\n    });\n  }\n\n  function createModule(name, testEnvironment, modifiers) {\n    var parentModule = moduleStack.length ? moduleStack.slice(-1)[0] : null;\n    var moduleName = parentModule !== null ? [parentModule.name, name].join(' > ') : name;\n    var parentSuite = parentModule ? parentModule.suiteReport : runSuite;\n    var skip = parentModule !== null && parentModule.skip || modifiers.skip;\n    var todo = parentModule !== null && parentModule.todo || modifiers.todo;\n    var env = {};\n\n    if (parentModule) {\n      extend(env, parentModule.testEnvironment);\n    }\n\n    extend(env, testEnvironment);\n    var module = {\n      name: moduleName,\n      parentModule: parentModule,\n      hooks: {\n        before: [],\n        beforeEach: [],\n        afterEach: [],\n        after: []\n      },\n      testEnvironment: env,\n      tests: [],\n      moduleId: generateHash(moduleName),\n      testsRun: 0,\n      testsIgnored: 0,\n      childModules: [],\n      suiteReport: new SuiteReport(name, parentSuite),\n      // Initialised by test.js when the module start executing,\n      // i.e. before the first test in this module (or a child).\n      stats: null,\n      // Pass along `skip` and `todo` properties from parent module, in case\n      // there is one, to childs. And use own otherwise.\n      // This property will be used to mark own tests and tests of child suites\n      // as either `skipped` or `todo`.\n      skip: skip,\n      todo: skip ? false : todo,\n      ignored: modifiers.ignored || false\n    };\n\n    if (parentModule) {\n      parentModule.childModules.push(module);\n    }\n\n    config.modules.push(module);\n    return module;\n  }\n\n  function setHookFromEnvironment(hooks, environment, name) {\n    var potentialHook = environment[name];\n\n    if (typeof potentialHook === 'function') {\n      hooks[name].push(potentialHook);\n    }\n\n    delete environment[name];\n  }\n\n  function makeSetHook(module, hookName) {\n    return function setHook(callback) {\n      if (config.currentModule !== module) {\n        Logger.warn('The `' + hookName + '` hook was called inside the wrong module (`' + config.currentModule.name + '`). ' + 'Instead, use hooks provided by the callback to the containing module (`' + module.name + '`). ' + 'This will become an error in QUnit 3.0.');\n      }\n\n      module.hooks[hookName].push(callback);\n    };\n  }\n\n  function processModule(name, options, executeNow) {\n    var modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    if (typeof options === 'function') {\n      executeNow = options;\n      options = undefined;\n    }\n\n    var module = createModule(name, options, modifiers); // Transfer any initial hooks from the options object to the 'hooks' object\n\n    var testEnvironment = module.testEnvironment;\n    var hooks = module.hooks;\n    setHookFromEnvironment(hooks, testEnvironment, 'before');\n    setHookFromEnvironment(hooks, testEnvironment, 'beforeEach');\n    setHookFromEnvironment(hooks, testEnvironment, 'afterEach');\n    setHookFromEnvironment(hooks, testEnvironment, 'after');\n    var moduleFns = {\n      before: makeSetHook(module, 'before'),\n      beforeEach: makeSetHook(module, 'beforeEach'),\n      afterEach: makeSetHook(module, 'afterEach'),\n      after: makeSetHook(module, 'after')\n    };\n    var prevModule = config.currentModule;\n    config.currentModule = module;\n\n    if (typeof executeNow === 'function') {\n      moduleStack.push(module);\n\n      try {\n        var cbReturnValue = executeNow.call(module.testEnvironment, moduleFns);\n\n        if (cbReturnValue && typeof cbReturnValue.then === 'function') {\n          Logger.warn('Returning a promise from a module callback is not supported. ' + 'Instead, use hooks for async behavior. ' + 'This will become an error in QUnit 3.0.');\n        }\n      } finally {\n        // If the module closure threw an uncaught error during the load phase,\n        // we let this bubble up to global error handlers. But, not until after\n        // we teardown internal state to ensure correct module nesting.\n        // Ref https://github.com/qunitjs/qunit/issues/1478.\n        moduleStack.pop();\n        config.currentModule = module.parentModule || prevModule;\n      }\n    }\n  }\n\n  var focused$1 = false; // indicates that the \"only\" filter was used\n\n  function module$1(name, options, executeNow) {\n    var ignored = focused$1 && !isParentModuleInQueue();\n    processModule(name, options, executeNow, {\n      ignored: ignored\n    });\n  }\n\n  module$1.only = function () {\n    if (!focused$1) {\n      // Upon the first module.only() call,\n      // delete any and all previously registered modules and tests.\n      config.modules.length = 0;\n      config.queue.length = 0; // Ignore any tests declared after this block within the same\n      // module parent. https://github.com/qunitjs/qunit/issues/1645\n\n      config.currentModule.ignored = true;\n    }\n\n    focused$1 = true;\n    processModule.apply(void 0, arguments);\n  };\n\n  module$1.skip = function (name, options, executeNow) {\n    if (focused$1) {\n      return;\n    }\n\n    processModule(name, options, executeNow, {\n      skip: true\n    });\n  };\n\n  module$1.todo = function (name, options, executeNow) {\n    if (focused$1) {\n      return;\n    }\n\n    processModule(name, options, executeNow, {\n      todo: true\n    });\n  };\n\n  // Doesn't support IE9, it will return undefined on these browsers\n  // See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\n  var fileName = (sourceFromStacktrace(0) || '').replace(/(:\\d+)+\\)?/, '') // Remove anything prior to the last slash (Unix/Windows)\n  // from the last frame\n  .replace(/.+[/\\\\]/, '');\n  function extractStacktrace(e, offset) {\n    offset = offset === undefined ? 4 : offset;\n\n    if (e && e.stack) {\n      var stack = e.stack.split('\\n');\n\n      if (/^error$/i.test(stack[0])) {\n        stack.shift();\n      }\n\n      if (fileName) {\n        var include = [];\n\n        for (var i = offset; i < stack.length; i++) {\n          if (stack[i].indexOf(fileName) !== -1) {\n            break;\n          }\n\n          include.push(stack[i]);\n        }\n\n        if (include.length) {\n          return include.join('\\n');\n        }\n      }\n\n      return stack[offset];\n    }\n  }\n  function sourceFromStacktrace(offset) {\n    var error = new Error(); // Support: Safari <=7 only, IE <=10 - 11 only\n    // Not all browsers generate the `stack` property for `new Error()`, see also #636\n\n    if (!error.stack) {\n      try {\n        throw error;\n      } catch (err) {\n        error = err;\n      }\n    }\n\n    return extractStacktrace(error, offset);\n  }\n\n  var Assert = /*#__PURE__*/function () {\n    function Assert(testContext) {\n      _classCallCheck(this, Assert);\n\n      this.test = testContext;\n    }\n\n    _createClass(Assert, [{\n      key: \"timeout\",\n      value: function timeout(duration) {\n        if (typeof duration !== 'number') {\n          throw new Error('You must pass a number as the duration to assert.timeout');\n        }\n\n        this.test.timeout = duration; // If a timeout has been set, clear it and reset with the new duration\n\n        if (config.timeout) {\n          clearTimeout(config.timeout);\n          config.timeout = null;\n\n          if (config.timeoutHandler && this.test.timeout > 0) {\n            this.test.internalResetTimeout(this.test.timeout);\n          }\n        }\n      } // Documents a \"step\", which is a string value, in a test as a passing assertion\n\n    }, {\n      key: \"step\",\n      value: function step(message) {\n        var assertionMessage = message;\n        var result = !!message;\n        this.test.steps.push(message);\n\n        if (typeof message === 'undefined' || message === '') {\n          assertionMessage = 'You must provide a message to assert.step';\n        } else if (typeof message !== 'string') {\n          assertionMessage = 'You must provide a string value to assert.step';\n          result = false;\n        }\n\n        this.pushResult({\n          result: result,\n          message: assertionMessage\n        });\n      } // Verifies the steps in a test match a given array of string values\n\n    }, {\n      key: \"verifySteps\",\n      value: function verifySteps(steps, message) {\n        // Since the steps array is just string values, we can clone with slice\n        var actualStepsClone = this.test.steps.slice();\n        this.deepEqual(actualStepsClone, steps, message);\n        this.test.steps.length = 0;\n      }\n    }, {\n      key: \"expect\",\n      value: function expect(asserts) {\n        if (arguments.length === 1) {\n          this.test.expected = asserts;\n        } else {\n          return this.test.expected;\n        }\n      } // Create a new async pause and return a new function that can release the pause.\n\n    }, {\n      key: \"async\",\n      value: function async(count) {\n        var requiredCalls = count === undefined ? 1 : count;\n        return this.test.internalStop(requiredCalls);\n      } // Exports test.push() to the user API\n      // Alias of pushResult.\n\n    }, {\n      key: \"push\",\n      value: function push(result, actual, expected, message, negative) {\n        Logger.warn('assert.push is deprecated and will be removed in QUnit 3.0.' + ' Please use assert.pushResult instead (https://api.qunitjs.com/assert/pushResult).');\n        var currentAssert = this instanceof Assert ? this : config.current.assert;\n        return currentAssert.pushResult({\n          result: result,\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: negative\n        });\n      }\n    }, {\n      key: \"pushResult\",\n      value: function pushResult(resultInfo) {\n        // Destructure of resultInfo = { result, actual, expected, message, negative }\n        var assert = this;\n        var currentTest = assert instanceof Assert && assert.test || config.current; // Backwards compatibility fix.\n        // Allows the direct use of global exported assertions and QUnit.assert.*\n        // Although, it's use is not recommended as it can leak assertions\n        // to other tests from async tests, because we only get a reference to the current test,\n        // not exactly the test where assertion were intended to be called.\n\n        if (!currentTest) {\n          throw new Error('assertion outside test context, in ' + sourceFromStacktrace(2));\n        }\n\n        if (!(assert instanceof Assert)) {\n          assert = currentTest.assert;\n        }\n\n        return assert.test.pushResult(resultInfo);\n      }\n    }, {\n      key: \"ok\",\n      value: function ok(result, message) {\n        if (!message) {\n          message = result ? 'okay' : \"failed, expected argument to be truthy, was: \".concat(dump.parse(result));\n        }\n\n        this.pushResult({\n          result: !!result,\n          actual: result,\n          expected: true,\n          message: message\n        });\n      }\n    }, {\n      key: \"notOk\",\n      value: function notOk(result, message) {\n        if (!message) {\n          message = !result ? 'okay' : \"failed, expected argument to be falsy, was: \".concat(dump.parse(result));\n        }\n\n        this.pushResult({\n          result: !result,\n          actual: result,\n          expected: false,\n          message: message\n        });\n      }\n    }, {\n      key: \"true\",\n      value: function _true(result, message) {\n        this.pushResult({\n          result: result === true,\n          actual: result,\n          expected: true,\n          message: message\n        });\n      }\n    }, {\n      key: \"false\",\n      value: function _false(result, message) {\n        this.pushResult({\n          result: result === false,\n          actual: result,\n          expected: false,\n          message: message\n        });\n      }\n    }, {\n      key: \"equal\",\n      value: function equal(actual, expected, message) {\n        // eslint-disable-next-line eqeqeq\n        var result = expected == actual;\n        this.pushResult({\n          result: result,\n          actual: actual,\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: \"notEqual\",\n      value: function notEqual(actual, expected, message) {\n        // eslint-disable-next-line eqeqeq\n        var result = expected != actual;\n        this.pushResult({\n          result: result,\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: true\n        });\n      }\n    }, {\n      key: \"propEqual\",\n      value: function propEqual(actual, expected, message) {\n        actual = objectValues(actual);\n        expected = objectValues(expected);\n        this.pushResult({\n          result: equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: \"notPropEqual\",\n      value: function notPropEqual(actual, expected, message) {\n        actual = objectValues(actual);\n        expected = objectValues(expected);\n        this.pushResult({\n          result: !equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: true\n        });\n      }\n    }, {\n      key: \"propContains\",\n      value: function propContains(actual, expected, message) {\n        actual = objectValuesSubset(actual, expected); // The expected parameter is usually a plain object, but clone it for\n        // consistency with propEqual(), and to make it easy to explain that\n        // inheritence is not considered (on either side), and to support\n        // recursively checking subsets of nested objects.\n\n        expected = objectValues(expected, false);\n        this.pushResult({\n          result: equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: \"notPropContains\",\n      value: function notPropContains(actual, expected, message) {\n        actual = objectValuesSubset(actual, expected);\n        expected = objectValues(expected);\n        this.pushResult({\n          result: !equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: true\n        });\n      }\n    }, {\n      key: \"deepEqual\",\n      value: function deepEqual(actual, expected, message) {\n        this.pushResult({\n          result: equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: \"notDeepEqual\",\n      value: function notDeepEqual(actual, expected, message) {\n        this.pushResult({\n          result: !equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: true\n        });\n      }\n    }, {\n      key: \"strictEqual\",\n      value: function strictEqual(actual, expected, message) {\n        this.pushResult({\n          result: expected === actual,\n          actual: actual,\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: \"notStrictEqual\",\n      value: function notStrictEqual(actual, expected, message) {\n        this.pushResult({\n          result: expected !== actual,\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: true\n        });\n      }\n    }, {\n      key: 'throws',\n      value: function throws(block, expected, message) {\n        var _validateExpectedExce = validateExpectedExceptionArgs(expected, message, 'throws');\n\n        var _validateExpectedExce2 = _slicedToArray(_validateExpectedExce, 2);\n\n        expected = _validateExpectedExce2[0];\n        message = _validateExpectedExce2[1];\n        var currentTest = this instanceof Assert && this.test || config.current;\n\n        if (typeof block !== 'function') {\n          var _message = 'The value provided to `assert.throws` in ' + '\"' + currentTest.testName + '\" was not a function.';\n\n          currentTest.assert.pushResult({\n            result: false,\n            actual: block,\n            message: _message\n          });\n          return;\n        }\n\n        var actual;\n        var result = false;\n        currentTest.ignoreGlobalErrors = true;\n\n        try {\n          block.call(currentTest.testEnvironment);\n        } catch (e) {\n          actual = e;\n        }\n\n        currentTest.ignoreGlobalErrors = false;\n\n        if (actual) {\n          var _validateException = validateException(actual, expected, message);\n\n          var _validateException2 = _slicedToArray(_validateException, 3);\n\n          result = _validateException2[0];\n          expected = _validateException2[1];\n          message = _validateException2[2];\n        }\n\n        currentTest.assert.pushResult({\n          result: result,\n          // undefined if it didn't throw\n          actual: actual && errorString(actual),\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: \"rejects\",\n      value: function rejects(promise, expected, message) {\n        var _validateExpectedExce3 = validateExpectedExceptionArgs(expected, message, 'rejects');\n\n        var _validateExpectedExce4 = _slicedToArray(_validateExpectedExce3, 2);\n\n        expected = _validateExpectedExce4[0];\n        message = _validateExpectedExce4[1];\n        var currentTest = this instanceof Assert && this.test || config.current;\n        var then = promise && promise.then;\n\n        if (typeof then !== 'function') {\n          var _message2 = 'The value provided to `assert.rejects` in ' + '\"' + currentTest.testName + '\" was not a promise.';\n\n          currentTest.assert.pushResult({\n            result: false,\n            message: _message2,\n            actual: promise\n          });\n          return;\n        }\n\n        var done = this.async();\n        return then.call(promise, function handleFulfillment() {\n          var message = 'The promise returned by the `assert.rejects` callback in ' + '\"' + currentTest.testName + '\" did not reject.';\n          currentTest.assert.pushResult({\n            result: false,\n            message: message,\n            actual: promise\n          });\n          done();\n        }, function handleRejection(actual) {\n          var result;\n\n          var _validateException3 = validateException(actual, expected, message);\n\n          var _validateException4 = _slicedToArray(_validateException3, 3);\n\n          result = _validateException4[0];\n          expected = _validateException4[1];\n          message = _validateException4[2];\n          currentTest.assert.pushResult({\n            result: result,\n            // leave rejection value of undefined as-is\n            actual: actual && errorString(actual),\n            expected: expected,\n            message: message\n          });\n          done();\n        });\n      }\n    }]);\n\n    return Assert;\n  }();\n\n  function validateExpectedExceptionArgs(expected, message, assertionMethod) {\n    var expectedType = objectType(expected); // 'expected' is optional unless doing string comparison\n\n    if (expectedType === 'string') {\n      if (message === undefined) {\n        message = expected;\n        expected = undefined;\n        return [expected, message];\n      } else {\n        throw new Error('assert.' + assertionMethod + ' does not accept a string value for the expected argument.\\n' + 'Use a non-string object value (e.g. RegExp or validator function) ' + 'instead if necessary.');\n      }\n    }\n\n    var valid = !expected || // TODO: be more explicit here\n    expectedType === 'regexp' || expectedType === 'function' || expectedType === 'object';\n\n    if (!valid) {\n      var _message3 = 'Invalid expected value type (' + expectedType + ') ' + 'provided to assert.' + assertionMethod + '.';\n\n      throw new Error(_message3);\n    }\n\n    return [expected, message];\n  }\n\n  function validateException(actual, expected, message) {\n    var result = false;\n    var expectedType = objectType(expected); // These branches should be exhaustive, based on validation done in validateExpectedException\n    // We don't want to validate\n\n    if (!expected) {\n      result = true; // Expected is a regexp\n    } else if (expectedType === 'regexp') {\n      result = expected.test(errorString(actual)); // Log the string form of the regexp\n\n      expected = String(expected); // Expected is a constructor, maybe an Error constructor.\n      // Note the extra check on its prototype - this is an implicit\n      // requirement of \"instanceof\", else it will throw a TypeError.\n    } else if (expectedType === 'function' && expected.prototype !== undefined && actual instanceof expected) {\n      result = true; // Expected is an Error object\n    } else if (expectedType === 'object') {\n      result = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message; // Log the string form of the Error object\n\n      expected = errorString(expected); // Expected is a validation function which returns true if validation passed\n    } else if (expectedType === 'function') {\n      // protect against accidental semantics which could hard error in the test\n      try {\n        result = expected.call({}, actual) === true;\n        expected = null;\n      } catch (e) {\n        // assign the \"expected\" to a nice error string to communicate the local failure to the user\n        expected = errorString(e);\n      }\n    }\n\n    return [result, expected, message];\n  } // Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n  // Known to us are: Closure Compiler, Narwhal\n  // eslint-disable-next-line dot-notation\n\n\n  Assert.prototype.raises = Assert.prototype['throws'];\n\n  var LISTENERS = Object.create(null);\n  var SUPPORTED_EVENTS = ['error', 'runStart', 'suiteStart', 'testStart', 'assertion', 'testEnd', 'suiteEnd', 'runEnd'];\n  /**\n   * Emits an event with the specified data to all currently registered listeners.\n   * Callbacks will fire in the order in which they are registered (FIFO). This\n   * function is not exposed publicly; it is used by QUnit internals to emit\n   * logging events.\n   *\n   * @private\n   * @method emit\n   * @param {string} eventName\n   * @param {Object} data\n   * @return {void}\n   */\n\n  function emit(eventName, data) {\n    if (typeof eventName !== 'string') {\n      throw new TypeError('eventName must be a string when emitting an event');\n    } // Clone the callbacks in case one of them registers a new callback\n\n\n    var originalCallbacks = LISTENERS[eventName];\n    var callbacks = originalCallbacks ? _toConsumableArray(originalCallbacks) : [];\n\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](data);\n    }\n  }\n  /**\n   * Registers a callback as a listener to the specified event.\n   *\n   * @public\n   * @method on\n   * @param {string} eventName\n   * @param {Function} callback\n   * @return {void}\n   */\n\n  function on(eventName, callback) {\n    if (typeof eventName !== 'string') {\n      throw new TypeError('eventName must be a string when registering a listener');\n    } else if (!inArray(eventName, SUPPORTED_EVENTS)) {\n      var events = SUPPORTED_EVENTS.join(', ');\n      throw new Error(\"\\\"\".concat(eventName, \"\\\" is not a valid event; must be one of: \").concat(events, \".\"));\n    } else if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function when registering a listener');\n    }\n\n    if (!LISTENERS[eventName]) {\n      LISTENERS[eventName] = [];\n    } // Don't register the same callback more than once\n\n\n    if (!inArray(callback, LISTENERS[eventName])) {\n      LISTENERS[eventName].push(callback);\n    }\n  }\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n  function commonjsRequire (path) {\n  \tthrow new Error('Could not dynamically require \"' + path + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n  }\n\n  var promisePolyfill = {exports: {}};\n\n  (function () {\n    /** @suppress {undefinedVars} */\n\n    var globalNS = function () {\n      // the only reliable means to get the global object is\n      // `Function('return this')()`\n      // However, this causes CSP violations in Chrome apps.\n      if (typeof globalThis !== 'undefined') {\n        return globalThis;\n      }\n\n      if (typeof self !== 'undefined') {\n        return self;\n      }\n\n      if (typeof window !== 'undefined') {\n        return window;\n      }\n\n      if (typeof commonjsGlobal !== 'undefined') {\n        return commonjsGlobal;\n      }\n\n      throw new Error('unable to locate global object');\n    }(); // Expose the polyfill if Promise is undefined or set to a\n    // non-function value. The latter can be due to a named HTMLElement\n    // being exposed by browsers for legacy reasons.\n    // https://github.com/taylorhakes/promise-polyfill/issues/114\n\n\n    if (typeof globalNS['Promise'] === 'function') {\n      promisePolyfill.exports = globalNS['Promise'];\n      return;\n    }\n    /**\n     * @this {Promise}\n     */\n\n\n    function finallyConstructor(callback) {\n      var constructor = this.constructor;\n      return this.then(function (value) {\n        // @ts-ignore\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        // @ts-ignore\n        return constructor.resolve(callback()).then(function () {\n          // @ts-ignore\n          return constructor.reject(reason);\n        });\n      });\n    }\n\n    function allSettled(arr) {\n      var P = this;\n      return new P(function (resolve, reject) {\n        if (!(arr && typeof arr.length !== 'undefined')) {\n          return reject(new TypeError(_typeof(arr) + ' ' + arr + ' is not iterable(cannot read property Symbol(Symbol.iterator))'));\n        }\n\n        var args = Array.prototype.slice.call(arr);\n        if (args.length === 0) return resolve([]);\n        var remaining = args.length;\n\n        function res(i, val) {\n          if (val && (_typeof(val) === 'object' || typeof val === 'function')) {\n            var then = val.then;\n\n            if (typeof then === 'function') {\n              then.call(val, function (val) {\n                res(i, val);\n              }, function (e) {\n                args[i] = {\n                  status: 'rejected',\n                  reason: e\n                };\n\n                if (--remaining === 0) {\n                  resolve(args);\n                }\n              });\n              return;\n            }\n          }\n\n          args[i] = {\n            status: 'fulfilled',\n            value: val\n          };\n\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        }\n\n        for (var i = 0; i < args.length; i++) {\n          res(i, args[i]);\n        }\n      });\n    } // Store setTimeout reference so promise-polyfill will be unaffected by\n    // other code modifying setTimeout (like sinon.useFakeTimers())\n\n\n    var setTimeoutFunc = setTimeout;\n\n    function isArray(x) {\n      return Boolean(x && typeof x.length !== 'undefined');\n    }\n\n    function noop() {} // Polyfill for Function.prototype.bind\n\n\n    function bind(fn, thisArg) {\n      return function () {\n        fn.apply(thisArg, arguments);\n      };\n    }\n    /**\n     * @constructor\n     * @param {Function} fn\n     */\n\n\n    function Promise(fn) {\n      if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');\n      if (typeof fn !== 'function') throw new TypeError('not a function');\n      /** @type {!number} */\n\n      this._state = 0;\n      /** @type {!boolean} */\n\n      this._handled = false;\n      /** @type {Promise|undefined} */\n\n      this._value = undefined;\n      /** @type {!Array<!Function>} */\n\n      this._deferreds = [];\n      doResolve(fn, this);\n    }\n\n    function handle(self, deferred) {\n      while (self._state === 3) {\n        self = self._value;\n      }\n\n      if (self._state === 0) {\n        self._deferreds.push(deferred);\n\n        return;\n      }\n\n      self._handled = true;\n\n      Promise._immediateFn(function () {\n        var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n\n        if (cb === null) {\n          (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n          return;\n        }\n\n        var ret;\n\n        try {\n          ret = cb(self._value);\n        } catch (e) {\n          reject(deferred.promise, e);\n          return;\n        }\n\n        resolve(deferred.promise, ret);\n      });\n    }\n\n    function resolve(self, newValue) {\n      try {\n        // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n        if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n\n        if (newValue && (_typeof(newValue) === 'object' || typeof newValue === 'function')) {\n          var then = newValue.then;\n\n          if (newValue instanceof Promise) {\n            self._state = 3;\n            self._value = newValue;\n            finale(self);\n            return;\n          } else if (typeof then === 'function') {\n            doResolve(bind(then, newValue), self);\n            return;\n          }\n        }\n\n        self._state = 1;\n        self._value = newValue;\n        finale(self);\n      } catch (e) {\n        reject(self, e);\n      }\n    }\n\n    function reject(self, newValue) {\n      self._state = 2;\n      self._value = newValue;\n      finale(self);\n    }\n\n    function finale(self) {\n      if (self._state === 2 && self._deferreds.length === 0) {\n        Promise._immediateFn(function () {\n          if (!self._handled) {\n            Promise._unhandledRejectionFn(self._value);\n          }\n        });\n      }\n\n      for (var i = 0, len = self._deferreds.length; i < len; i++) {\n        handle(self, self._deferreds[i]);\n      }\n\n      self._deferreds = null;\n    }\n    /**\n     * @constructor\n     */\n\n\n    function Handler(onFulfilled, onRejected, promise) {\n      this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n      this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n      this.promise = promise;\n    }\n    /**\n     * Take a potentially misbehaving resolver function and make sure\n     * onFulfilled and onRejected are only called once.\n     *\n     * Makes no guarantees about asynchrony.\n     */\n\n\n    function doResolve(fn, self) {\n      var done = false;\n\n      try {\n        fn(function (value) {\n          if (done) return;\n          done = true;\n          resolve(self, value);\n        }, function (reason) {\n          if (done) return;\n          done = true;\n          reject(self, reason);\n        });\n      } catch (ex) {\n        if (done) return;\n        done = true;\n        reject(self, ex);\n      }\n    }\n\n    Promise.prototype['catch'] = function (onRejected) {\n      return this.then(null, onRejected);\n    };\n\n    Promise.prototype.then = function (onFulfilled, onRejected) {\n      // @ts-ignore\n      var prom = new this.constructor(noop);\n      handle(this, new Handler(onFulfilled, onRejected, prom));\n      return prom;\n    };\n\n    Promise.prototype['finally'] = finallyConstructor;\n\n    Promise.all = function (arr) {\n      return new Promise(function (resolve, reject) {\n        if (!isArray(arr)) {\n          return reject(new TypeError('Promise.all accepts an array'));\n        }\n\n        var args = Array.prototype.slice.call(arr);\n        if (args.length === 0) return resolve([]);\n        var remaining = args.length;\n\n        function res(i, val) {\n          try {\n            if (val && (_typeof(val) === 'object' || typeof val === 'function')) {\n              var then = val.then;\n\n              if (typeof then === 'function') {\n                then.call(val, function (val) {\n                  res(i, val);\n                }, reject);\n                return;\n              }\n            }\n\n            args[i] = val;\n\n            if (--remaining === 0) {\n              resolve(args);\n            }\n          } catch (ex) {\n            reject(ex);\n          }\n        }\n\n        for (var i = 0; i < args.length; i++) {\n          res(i, args[i]);\n        }\n      });\n    };\n\n    Promise.allSettled = allSettled;\n\n    Promise.resolve = function (value) {\n      if (value && _typeof(value) === 'object' && value.constructor === Promise) {\n        return value;\n      }\n\n      return new Promise(function (resolve) {\n        resolve(value);\n      });\n    };\n\n    Promise.reject = function (value) {\n      return new Promise(function (resolve, reject) {\n        reject(value);\n      });\n    };\n\n    Promise.race = function (arr) {\n      return new Promise(function (resolve, reject) {\n        if (!isArray(arr)) {\n          return reject(new TypeError('Promise.race accepts an array'));\n        }\n\n        for (var i = 0, len = arr.length; i < len; i++) {\n          Promise.resolve(arr[i]).then(resolve, reject);\n        }\n      });\n    }; // Use polyfill for setImmediate for performance gains\n\n\n    Promise._immediateFn = // @ts-ignore\n    typeof setImmediate === 'function' && function (fn) {\n      // @ts-ignore\n      setImmediate(fn);\n    } || function (fn) {\n      setTimeoutFunc(fn, 0);\n    };\n\n    Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n      if (typeof console !== 'undefined' && console) {\n        console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n      }\n    };\n\n    promisePolyfill.exports = Promise;\n  })();\n\n  var _Promise = promisePolyfill.exports;\n\n  function registerLoggingCallbacks(obj) {\n    var callbackNames = ['begin', 'done', 'log', 'testStart', 'testDone', 'moduleStart', 'moduleDone'];\n\n    function registerLoggingCallback(key) {\n      return function loggingCallback(callback) {\n        if (typeof callback !== 'function') {\n          throw new Error('Callback parameter must be a function');\n        }\n\n        config.callbacks[key].push(callback);\n      };\n    }\n\n    for (var i = 0; i < callbackNames.length; i++) {\n      var key = callbackNames[i]; // Initialize key collection of logging callback\n\n      if (typeof config.callbacks[key] === 'undefined') {\n        config.callbacks[key] = [];\n      }\n\n      obj[key] = registerLoggingCallback(key);\n    }\n  }\n  function runLoggingCallbacks(key, args) {\n    var callbacks = config.callbacks[key]; // Handling 'log' callbacks separately. Unlike the other callbacks,\n    // the log callback is not controlled by the processing queue,\n    // but rather used by asserts. Hence to promisfy the 'log' callback\n    // would mean promisfying each step of a test\n\n    if (key === 'log') {\n      callbacks.map(function (callback) {\n        return callback(args);\n      });\n      return;\n    } // ensure that each callback is executed serially\n\n\n    var promiseChain = _Promise.resolve();\n    callbacks.forEach(function (callback) {\n      promiseChain = promiseChain.then(function () {\n        return _Promise.resolve(callback(args));\n      });\n    });\n    return promiseChain;\n  }\n\n  var priorityCount = 0;\n  var unitSampler; // This is a queue of functions that are tasks within a single test.\n  // After tests are dequeued from config.queue they are expanded into\n  // a set of tasks in this queue.\n\n  var taskQueue = [];\n  /**\n   * Advances the taskQueue to the next task. If the taskQueue is empty,\n   * process the testQueue\n   */\n\n  function advance() {\n    advanceTaskQueue();\n\n    if (!taskQueue.length && !config.blocking && !config.current) {\n      advanceTestQueue();\n    }\n  }\n  /**\n   * Advances the taskQueue with an increased depth\n   */\n\n\n  function advanceTaskQueue() {\n    var start = performance.now();\n    config.depth = (config.depth || 0) + 1;\n    processTaskQueue(start);\n    config.depth--;\n  }\n  /**\n   * Process the first task on the taskQueue as a promise.\n   * Each task is a function added by Test#queue() in /src/test.js\n   */\n\n\n  function processTaskQueue(start) {\n    if (taskQueue.length && !config.blocking) {\n      var elapsedTime = performance.now() - start; // The updateRate ensures that a user interface (HTML Reporter) can be updated\n      // at least once every second. This can also prevent browsers from prompting\n      // a warning about long running scripts.\n\n      if (!setTimeout$1 || config.updateRate <= 0 || elapsedTime < config.updateRate) {\n        var task = taskQueue.shift();\n        _Promise.resolve(task()).then(function () {\n          if (!taskQueue.length) {\n            advance();\n          } else {\n            processTaskQueue(start);\n          }\n        });\n      } else {\n        setTimeout$1(advance);\n      }\n    }\n  }\n  /**\n   * Advance the testQueue to the next test to process. Call done() if testQueue completes.\n   */\n\n\n  function advanceTestQueue() {\n    if (!config.blocking && !config.queue.length && config.depth === 0) {\n      done();\n      return;\n    }\n\n    var testTasks = config.queue.shift();\n    addToTaskQueue(testTasks());\n\n    if (priorityCount > 0) {\n      priorityCount--;\n    }\n\n    advance();\n  }\n  /**\n   * Enqueue the tasks for a test into the task queue.\n   * @param {Array} tasksArray\n   */\n\n\n  function addToTaskQueue(tasksArray) {\n    taskQueue.push.apply(taskQueue, _toConsumableArray(tasksArray));\n  }\n  /**\n   * Return the number of tasks remaining in the task queue to be processed.\n   * @return {number}\n   */\n\n\n  function taskQueueLength() {\n    return taskQueue.length;\n  }\n  /**\n   * Adds a test to the TestQueue for execution.\n   * @param {Function} testTasksFunc\n   * @param {boolean} prioritize\n   * @param {string} seed\n   */\n\n\n  function addToTestQueue(testTasksFunc, prioritize, seed) {\n    if (prioritize) {\n      config.queue.splice(priorityCount++, 0, testTasksFunc);\n    } else if (seed) {\n      if (!unitSampler) {\n        unitSampler = unitSamplerGenerator(seed);\n      } // Insert into a random position after all prioritized items\n\n\n      var index = Math.floor(unitSampler() * (config.queue.length - priorityCount + 1));\n      config.queue.splice(priorityCount + index, 0, testTasksFunc);\n    } else {\n      config.queue.push(testTasksFunc);\n    }\n  }\n  /**\n   * Creates a seeded \"sample\" generator which is used for randomizing tests.\n   */\n\n\n  function unitSamplerGenerator(seed) {\n    // 32-bit xorshift, requires only a nonzero seed\n    // https://excamera.com/sphinx/article-xorshift.html\n    var sample = parseInt(generateHash(seed), 16) || -1;\n    return function () {\n      sample ^= sample << 13;\n      sample ^= sample >>> 17;\n      sample ^= sample << 5; // ECMAScript has no unsigned number type\n\n      if (sample < 0) {\n        sample += 0x100000000;\n      }\n\n      return sample / 0x100000000;\n    };\n  }\n  /**\n   * This function is called when the ProcessingQueue is done processing all\n   * items. It handles emitting the final run events.\n   */\n\n\n  function done() {\n    // We have reached the end of the processing queue and are about to emit the\n    // \"runEnd\" event after which reporters typically stop listening and exit\n    // the process. First, check if we need to emit one final test.\n    if (config.stats.testCount === 0 && config.failOnZeroTests === true) {\n      var error;\n\n      if (config.filter && config.filter.length) {\n        error = new Error(\"No tests matched the filter \\\"\".concat(config.filter, \"\\\".\"));\n      } else if (config.module && config.module.length) {\n        error = new Error(\"No tests matched the module \\\"\".concat(config.module, \"\\\".\"));\n      } else if (config.moduleId && config.moduleId.length) {\n        error = new Error(\"No tests matched the moduleId \\\"\".concat(config.moduleId, \"\\\".\"));\n      } else if (config.testId && config.testId.length) {\n        error = new Error(\"No tests matched the testId \\\"\".concat(config.testId, \"\\\".\"));\n      } else {\n        error = new Error('No tests were run.');\n      }\n\n      test('global failure', extend(function (assert) {\n        assert.pushResult({\n          result: false,\n          message: error.message,\n          source: error.stack\n        });\n      }, {\n        validTest: true\n      })); // We do need to call `advance()` in order to resume the processing queue.\n      // Once this new test is finished processing, we'll reach `done` again, and\n      // that time the above condition will evaluate to false.\n\n      advance();\n      return;\n    }\n\n    var storage = config.storage;\n    var runtime = Math.round(performance.now() - config.started);\n    var passed = config.stats.all - config.stats.bad;\n    ProcessingQueue.finished = true;\n    emit('runEnd', runSuite.end(true));\n    runLoggingCallbacks('done', {\n      // @deprecated since 2.19.0 Use done() without `details` parameter,\n      // or use `QUnit.on('runEnd')` instead. Parameter to be replaced in\n      // QUnit 3.0 with test counts.\n      passed: passed,\n      failed: config.stats.bad,\n      total: config.stats.all,\n      runtime: runtime\n    }).then(function () {\n      // Clear own storage items if all tests passed\n      if (storage && config.stats.bad === 0) {\n        for (var i = storage.length - 1; i >= 0; i--) {\n          var key = storage.key(i);\n\n          if (key.indexOf('qunit-test-') === 0) {\n            storage.removeItem(key);\n          }\n        }\n      }\n    });\n  }\n\n  var ProcessingQueue = {\n    finished: false,\n    add: addToTestQueue,\n    advance: advance,\n    taskCount: taskQueueLength\n  };\n\n  var TestReport = /*#__PURE__*/function () {\n    function TestReport(name, suite, options) {\n      _classCallCheck(this, TestReport);\n\n      this.name = name;\n      this.suiteName = suite.name;\n      this.fullName = suite.fullName.concat(name);\n      this.runtime = 0;\n      this.assertions = [];\n      this.skipped = !!options.skip;\n      this.todo = !!options.todo;\n      this.valid = options.valid;\n      this._startTime = 0;\n      this._endTime = 0;\n      suite.pushTest(this);\n    }\n\n    _createClass(TestReport, [{\n      key: \"start\",\n      value: function start(recordTime) {\n        if (recordTime) {\n          this._startTime = performance.now();\n          performance.mark('qunit_test_start');\n        }\n\n        return {\n          name: this.name,\n          suiteName: this.suiteName,\n          fullName: this.fullName.slice()\n        };\n      }\n    }, {\n      key: \"end\",\n      value: function end(recordTime) {\n        if (recordTime) {\n          this._endTime = performance.now();\n\n          if (performance) {\n            performance.mark('qunit_test_end');\n            var testName = this.fullName.join(' – ');\n            performance.measure(\"QUnit Test: \".concat(testName), 'qunit_test_start', 'qunit_test_end');\n          }\n        }\n\n        return extend(this.start(), {\n          runtime: this.getRuntime(),\n          status: this.getStatus(),\n          errors: this.getFailedAssertions(),\n          assertions: this.getAssertions()\n        });\n      }\n    }, {\n      key: \"pushAssertion\",\n      value: function pushAssertion(assertion) {\n        this.assertions.push(assertion);\n      }\n    }, {\n      key: \"getRuntime\",\n      value: function getRuntime() {\n        return Math.round(this._endTime - this._startTime);\n      }\n    }, {\n      key: \"getStatus\",\n      value: function getStatus() {\n        if (this.skipped) {\n          return 'skipped';\n        }\n\n        var testPassed = this.getFailedAssertions().length > 0 ? this.todo : !this.todo;\n\n        if (!testPassed) {\n          return 'failed';\n        } else if (this.todo) {\n          return 'todo';\n        } else {\n          return 'passed';\n        }\n      }\n    }, {\n      key: \"getFailedAssertions\",\n      value: function getFailedAssertions() {\n        return this.assertions.filter(function (assertion) {\n          return !assertion.passed;\n        });\n      }\n    }, {\n      key: \"getAssertions\",\n      value: function getAssertions() {\n        return this.assertions.slice();\n      } // Remove actual and expected values from assertions. This is to prevent\n      // leaking memory throughout a test suite.\n\n    }, {\n      key: \"slimAssertions\",\n      value: function slimAssertions() {\n        this.assertions = this.assertions.map(function (assertion) {\n          delete assertion.actual;\n          delete assertion.expected;\n          return assertion;\n        });\n      }\n    }]);\n\n    return TestReport;\n  }();\n\n  function Test(settings) {\n    this.expected = null;\n    this.assertions = [];\n    this.module = config.currentModule;\n    this.steps = [];\n    this.timeout = undefined;\n    this.data = undefined;\n    this.withData = false;\n    this.pauses = new StringMap();\n    this.nextPauseId = 1; // For the most common case, we have:\n    // - 0: new Test\n    // - 1: addTest\n    // - 2: QUnit.test\n    // - 3: user file\n    //\n    // This needs is customised by test.each()\n\n    this.stackOffset = 3;\n    extend(this, settings); // If a module is skipped, all its tests and the tests of the child suites\n    // should be treated as skipped even if they are defined as `only` or `todo`.\n    // As for `todo` module, all its tests will be treated as `todo` except for\n    // tests defined as `skip` which will be left intact.\n    //\n    // So, if a test is defined as `todo` and is inside a skipped module, we should\n    // then treat that test as if was defined as `skip`.\n\n    if (this.module.skip) {\n      this.skip = true;\n      this.todo = false; // Skipped tests should be left intact\n    } else if (this.module.todo && !this.skip) {\n      this.todo = true;\n    } // Queuing a late test after the run has ended is not allowed.\n    // This was once supported for internal use by QUnit.onError().\n    // Ref https://github.com/qunitjs/qunit/issues/1377\n\n\n    if (ProcessingQueue.finished) {\n      // Using this for anything other than onError(), such as testing in QUnit.done(),\n      // is unstable and will likely result in the added tests being ignored by CI.\n      // (Meaning the CI passes irregardless of the added tests).\n      //\n      // TODO: Make this an error in QUnit 3.0\n      // throw new Error( \"Unexpected new test after the run already ended\" );\n      Logger.warn('Unexpected test after runEnd. This is unstable and will fail in QUnit 3.0.');\n      return;\n    }\n\n    if (!this.skip && typeof this.callback !== 'function') {\n      var method = this.todo ? 'QUnit.todo' : 'QUnit.test';\n      throw new TypeError(\"You must provide a callback to \".concat(method, \"(\\\"\").concat(this.testName, \"\\\")\"));\n    } // No validation after this. Beyond this point, failures must be recorded as\n    // a completed test with errors, instead of early bail out.\n    // Otherwise, internals may be left in an inconsistent state.\n    // Ref https://github.com/qunitjs/qunit/issues/1514\n\n\n    ++Test.count;\n    this.errorForStack = new Error();\n\n    if (this.callback && this.callback.validTest) {\n      // Omit the test-level trace for the internal \"No tests\" test failure,\n      // There is already an assertion-level trace, and that's noisy enough\n      // as it is.\n      this.errorForStack.stack = undefined;\n    }\n\n    this.testReport = new TestReport(this.testName, this.module.suiteReport, {\n      todo: this.todo,\n      skip: this.skip,\n      valid: this.valid()\n    }); // Register unique strings\n\n    for (var i = 0, l = this.module.tests; i < l.length; i++) {\n      if (this.module.tests[i].name === this.testName) {\n        this.testName += ' ';\n      }\n    }\n\n    this.testId = generateHash(this.module.name, this.testName);\n    this.module.tests.push({\n      name: this.testName,\n      testId: this.testId,\n      skip: !!this.skip\n    });\n\n    if (this.skip) {\n      // Skipped tests will fully ignore any sent callback\n      this.callback = function () {};\n\n      this.async = false;\n      this.expected = 0;\n    } else {\n      this.assert = new Assert(this);\n    }\n  }\n  Test.count = 0;\n\n  function getNotStartedModules(startModule) {\n    var module = startModule;\n    var modules = [];\n\n    while (module && module.testsRun === 0) {\n      modules.push(module);\n      module = module.parentModule;\n    } // The above push modules from the child to the parent\n    // return a reversed order with the top being the top most parent module\n\n\n    return modules.reverse();\n  }\n\n  Test.prototype = {\n    // Use a getter to avoid computing a stack trace (which can be expensive),\n    // This is displayed by the HTML Reporter, but most other integrations do\n    // not access it.\n    get stack() {\n      return extractStacktrace(this.errorForStack, this.stackOffset);\n    },\n\n    before: function before() {\n      var _this = this;\n\n      var module = this.module;\n      var notStartedModules = getNotStartedModules(module); // ensure the callbacks are executed serially for each module\n\n      var moduleStartChain = _Promise.resolve();\n      notStartedModules.forEach(function (startModule) {\n        moduleStartChain = moduleStartChain.then(function () {\n          startModule.stats = {\n            all: 0,\n            bad: 0,\n            started: performance.now()\n          };\n          emit('suiteStart', startModule.suiteReport.start(true));\n          return runLoggingCallbacks('moduleStart', {\n            name: startModule.name,\n            tests: startModule.tests\n          });\n        });\n      });\n      return moduleStartChain.then(function () {\n        config.current = _this;\n        _this.testEnvironment = extend({}, module.testEnvironment);\n        _this.started = performance.now();\n        emit('testStart', _this.testReport.start(true));\n        return runLoggingCallbacks('testStart', {\n          name: _this.testName,\n          module: module.name,\n          testId: _this.testId,\n          previousFailure: _this.previousFailure\n        }).then(function () {\n          if (!config.pollution) {\n            saveGlobal();\n          }\n        });\n      });\n    },\n    run: function run() {\n      config.current = this;\n\n      if (config.notrycatch) {\n        runTest(this);\n        return;\n      }\n\n      try {\n        runTest(this);\n      } catch (e) {\n        this.pushFailure('Died on test #' + (this.assertions.length + 1) + ': ' + (e.message || e) + '\\n' + this.stack, extractStacktrace(e, 0)); // Else next test will carry the responsibility\n\n        saveGlobal(); // Restart the tests if they're blocking\n\n        if (config.blocking) {\n          internalRecover(this);\n        }\n      }\n\n      function runTest(test) {\n        var promise;\n\n        if (test.withData) {\n          promise = test.callback.call(test.testEnvironment, test.assert, test.data);\n        } else {\n          promise = test.callback.call(test.testEnvironment, test.assert);\n        }\n\n        test.resolvePromise(promise); // If the test has an async \"pause\" on it, but the timeout is 0, then we push a\n        // failure as the test should be synchronous.\n\n        if (test.timeout === 0 && test.pauses.size > 0) {\n          pushFailure('Test did not finish synchronously even though assert.timeout( 0 ) was used.', sourceFromStacktrace(2));\n        }\n      }\n    },\n    after: function after() {\n      checkPollution();\n    },\n    queueGlobalHook: function queueGlobalHook(hook, hookName) {\n      var _this2 = this;\n\n      var runHook = function runHook() {\n        config.current = _this2;\n        var promise;\n\n        if (config.notrycatch) {\n          promise = hook.call(_this2.testEnvironment, _this2.assert);\n        } else {\n          try {\n            promise = hook.call(_this2.testEnvironment, _this2.assert);\n          } catch (error) {\n            _this2.pushFailure('Global ' + hookName + ' failed on ' + _this2.testName + ': ' + errorString(error), extractStacktrace(error, 0));\n\n            return;\n          }\n        }\n\n        _this2.resolvePromise(promise, hookName);\n      };\n\n      return runHook;\n    },\n    queueHook: function queueHook(hook, hookName, hookOwner) {\n      var _this3 = this;\n\n      var callHook = function callHook() {\n        var promise = hook.call(_this3.testEnvironment, _this3.assert);\n\n        _this3.resolvePromise(promise, hookName);\n      };\n\n      var runHook = function runHook() {\n        if (hookName === 'before') {\n          if (hookOwner.testsRun !== 0) {\n            return;\n          }\n\n          _this3.preserveEnvironment = true;\n        } // The 'after' hook should only execute when there are not tests left and\n        // when the 'after' and 'finish' tasks are the only tasks left to process\n\n\n        if (hookName === 'after' && !lastTestWithinModuleExecuted(hookOwner) && (config.queue.length > 0 || ProcessingQueue.taskCount() > 2)) {\n          return;\n        }\n\n        config.current = _this3;\n\n        if (config.notrycatch) {\n          callHook();\n          return;\n        }\n\n        try {\n          // This try-block includes the indirect call to resolvePromise, which shouldn't\n          // have to be inside try-catch. But, since we support any user-provided thenable\n          // object, the thenable might throw in some unexpected way.\n          // This subtle behaviour is undocumented. To avoid new failures in minor releases\n          // we will not change this until QUnit 3.\n          // TODO: In QUnit 3, reduce this try-block to just hook.call(), matching\n          // the simplicity of queueGlobalHook.\n          callHook();\n        } catch (error) {\n          _this3.pushFailure(hookName + ' failed on ' + _this3.testName + ': ' + (error.message || error), extractStacktrace(error, 0));\n        }\n      };\n\n      return runHook;\n    },\n    // Currently only used for module level hooks, can be used to add global level ones\n    hooks: function hooks(handler) {\n      var hooks = [];\n\n      function processGlobalhooks(test) {\n        if ((handler === 'beforeEach' || handler === 'afterEach') && config.globalHooks[handler]) {\n          for (var i = 0; i < config.globalHooks[handler].length; i++) {\n            hooks.push(test.queueGlobalHook(config.globalHooks[handler][i], handler));\n          }\n        }\n      }\n\n      function processHooks(test, module) {\n        if (module.parentModule) {\n          processHooks(test, module.parentModule);\n        }\n\n        if (module.hooks[handler].length) {\n          for (var i = 0; i < module.hooks[handler].length; i++) {\n            hooks.push(test.queueHook(module.hooks[handler][i], handler, module));\n          }\n        }\n      } // Hooks are ignored on skipped tests\n\n\n      if (!this.skip) {\n        processGlobalhooks(this);\n        processHooks(this, this.module);\n      }\n\n      return hooks;\n    },\n    finish: function finish() {\n      config.current = this; // Release the test callback to ensure that anything referenced has been\n      // released to be garbage collected.\n\n      this.callback = undefined;\n\n      if (this.steps.length) {\n        var stepsList = this.steps.join(', ');\n        this.pushFailure('Expected assert.verifySteps() to be called before end of test ' + \"after using assert.step(). Unverified steps: \".concat(stepsList), this.stack);\n      }\n\n      if (config.requireExpects && this.expected === null) {\n        this.pushFailure('Expected number of assertions to be defined, but expect() was ' + 'not called.', this.stack);\n      } else if (this.expected !== null && this.expected !== this.assertions.length) {\n        this.pushFailure('Expected ' + this.expected + ' assertions, but ' + this.assertions.length + ' were run', this.stack);\n      } else if (this.expected === null && !this.assertions.length) {\n        this.pushFailure('Expected at least one assertion, but none were run - call ' + 'expect(0) to accept zero assertions.', this.stack);\n      }\n\n      var module = this.module;\n      var moduleName = module.name;\n      var testName = this.testName;\n      var skipped = !!this.skip;\n      var todo = !!this.todo;\n      var bad = 0;\n      var storage = config.storage;\n      this.runtime = Math.round(performance.now() - this.started);\n      config.stats.all += this.assertions.length;\n      config.stats.testCount += 1;\n      module.stats.all += this.assertions.length;\n\n      for (var i = 0; i < this.assertions.length; i++) {\n        // A failing assertion will counts toward the HTML Reporter's\n        // \"X assertions, Y failed\" line even if it was inside a todo.\n        // Inverting this would be similarly confusing since all but the last\n        // passing assertion inside a todo test should be considered as good.\n        // These stats don't decide the outcome of anything, so counting them\n        // as failing seems the most intuitive.\n        if (!this.assertions[i].result) {\n          bad++;\n          config.stats.bad++;\n          module.stats.bad++;\n        }\n      }\n\n      if (skipped) {\n        incrementTestsIgnored(module);\n      } else {\n        incrementTestsRun(module);\n      } // Store result when possible.\n      // Note that this also marks todo tests as bad, thus they get hoisted,\n      // and always run first on refresh.\n\n\n      if (storage) {\n        if (bad) {\n          storage.setItem('qunit-test-' + moduleName + '-' + testName, bad);\n        } else {\n          storage.removeItem('qunit-test-' + moduleName + '-' + testName);\n        }\n      } // After emitting the js-reporters event we cleanup the assertion data to\n      // avoid leaking it. It is not used by the legacy testDone callbacks.\n\n\n      emit('testEnd', this.testReport.end(true));\n      this.testReport.slimAssertions();\n      var test = this;\n      return runLoggingCallbacks('testDone', {\n        name: testName,\n        module: moduleName,\n        skipped: skipped,\n        todo: todo,\n        failed: bad,\n        passed: this.assertions.length - bad,\n        total: this.assertions.length,\n        runtime: skipped ? 0 : this.runtime,\n        // HTML Reporter use\n        assertions: this.assertions,\n        testId: this.testId,\n\n        // Source of Test\n        // generating stack trace is expensive, so using a getter will help defer this until we need it\n        get source() {\n          return test.stack;\n        }\n\n      }).then(function () {\n        if (allTestsExecuted(module)) {\n          var completedModules = [module]; // Check if the parent modules, iteratively, are done. If that the case,\n          // we emit the `suiteEnd` event and trigger `moduleDone` callback.\n\n          var parent = module.parentModule;\n\n          while (parent && allTestsExecuted(parent)) {\n            completedModules.push(parent);\n            parent = parent.parentModule;\n          }\n\n          var moduleDoneChain = _Promise.resolve();\n          completedModules.forEach(function (completedModule) {\n            moduleDoneChain = moduleDoneChain.then(function () {\n              return logSuiteEnd(completedModule);\n            });\n          });\n          return moduleDoneChain;\n        }\n      }).then(function () {\n        config.current = undefined;\n      });\n\n      function logSuiteEnd(module) {\n        // Reset `module.hooks` to ensure that anything referenced in these hooks\n        // has been released to be garbage collected. Descendant modules that were\n        // entirely skipped, e.g. due to filtering, will never have this method\n        // called for them, but might have hooks with references pinning data in\n        // memory (even if the hooks weren't actually executed), so we reset the\n        // hooks on all descendant modules here as well. This is safe because we\n        // will never call this as long as any descendant modules still have tests\n        // to run. This also means that in multi-tiered nesting scenarios we might\n        // reset the hooks multiple times on some modules, but that's harmless.\n        var modules = [module];\n\n        while (modules.length) {\n          var nextModule = modules.shift();\n          nextModule.hooks = {};\n          modules.push.apply(modules, _toConsumableArray(nextModule.childModules));\n        }\n\n        emit('suiteEnd', module.suiteReport.end(true));\n        return runLoggingCallbacks('moduleDone', {\n          name: module.name,\n          tests: module.tests,\n          failed: module.stats.bad,\n          passed: module.stats.all - module.stats.bad,\n          total: module.stats.all,\n          runtime: Math.round(performance.now() - module.stats.started)\n        });\n      }\n    },\n    preserveTestEnvironment: function preserveTestEnvironment() {\n      if (this.preserveEnvironment) {\n        this.module.testEnvironment = this.testEnvironment;\n        this.testEnvironment = extend({}, this.module.testEnvironment);\n      }\n    },\n    queue: function queue() {\n      var test = this;\n\n      if (!this.valid()) {\n        incrementTestsIgnored(this.module);\n        return;\n      }\n\n      function runTest() {\n        return [function () {\n          return test.before();\n        }].concat(_toConsumableArray(test.hooks('before')), [function () {\n          test.preserveTestEnvironment();\n        }], _toConsumableArray(test.hooks('beforeEach')), [function () {\n          test.run();\n        }], _toConsumableArray(test.hooks('afterEach').reverse()), _toConsumableArray(test.hooks('after').reverse()), [function () {\n          test.after();\n        }, function () {\n          return test.finish();\n        }]);\n      }\n\n      var previousFailCount = config.storage && +config.storage.getItem('qunit-test-' + this.module.name + '-' + this.testName); // Prioritize previously failed tests, detected from storage\n\n      var prioritize = config.reorder && !!previousFailCount;\n      this.previousFailure = !!previousFailCount;\n      ProcessingQueue.add(runTest, prioritize, config.seed);\n    },\n    pushResult: function pushResult(resultInfo) {\n      if (this !== config.current) {\n        var message = resultInfo && resultInfo.message || '';\n        var testName = this && this.testName || '';\n        var error = 'Assertion occurred after test finished.\\n' + '> Test: ' + testName + '\\n' + '> Message: ' + message + '\\n';\n        throw new Error(error);\n      } // Destructure of resultInfo = { result, actual, expected, message, negative }\n\n\n      var details = {\n        module: this.module.name,\n        name: this.testName,\n        result: resultInfo.result,\n        message: resultInfo.message,\n        actual: resultInfo.actual,\n        testId: this.testId,\n        negative: resultInfo.negative || false,\n        runtime: Math.round(performance.now() - this.started),\n        todo: !!this.todo\n      };\n\n      if (hasOwn$1.call(resultInfo, 'expected')) {\n        details.expected = resultInfo.expected;\n      }\n\n      if (!resultInfo.result) {\n        var source = resultInfo.source || sourceFromStacktrace();\n\n        if (source) {\n          details.source = source;\n        }\n      }\n\n      this.logAssertion(details);\n      this.assertions.push({\n        result: !!resultInfo.result,\n        message: resultInfo.message\n      });\n    },\n    pushFailure: function pushFailure(message, source, actual) {\n      if (!(this instanceof Test)) {\n        throw new Error('pushFailure() assertion outside test context, was ' + sourceFromStacktrace(2));\n      }\n\n      this.pushResult({\n        result: false,\n        message: message || 'error',\n        actual: actual || null,\n        source: source\n      });\n    },\n\n    /**\n     * Log assertion details using both the old QUnit.log interface and\n     * QUnit.on( \"assertion\" ) interface.\n     *\n     * @private\n     */\n    logAssertion: function logAssertion(details) {\n      runLoggingCallbacks('log', details);\n      var assertion = {\n        passed: details.result,\n        actual: details.actual,\n        expected: details.expected,\n        message: details.message,\n        stack: details.source,\n        todo: details.todo\n      };\n      this.testReport.pushAssertion(assertion);\n      emit('assertion', assertion);\n    },\n\n    /**\n     * Reset config.timeout with a new timeout duration.\n     *\n     * @param {number} timeoutDuration\n     */\n    internalResetTimeout: function internalResetTimeout(timeoutDuration) {\n      clearTimeout(config.timeout);\n      config.timeout = setTimeout$1(config.timeoutHandler(timeoutDuration), timeoutDuration);\n    },\n\n    /**\n     * Create a new async pause and return a new function that can release the pause.\n     *\n     * This mechanism is internally used by:\n     *\n     * - explicit async pauses, created by calling `assert.async()`,\n     * - implicit async pauses, created when `QUnit.test()` or module hook callbacks\n     *   use async-await or otherwise return a Promise.\n     *\n     * Happy scenario:\n     *\n     * - Pause is created by calling internalStop().\n     *\n     *   Pause is released normally by invoking release() during the same test.\n     *\n     *   The release() callback lets internal processing resume.\n     *\n     * Failure scenarios:\n     *\n     * - The test fails due to an uncaught exception.\n     *\n     *   In this case, Test.run() will call internalRecover() which empties the clears all\n     *   async pauses and sets the cancelled flag, which means we silently ignore any\n     *   late calls to the resume() callback, as we will have moved on to a different\n     *   test by then, and we don't want to cause an extra \"release during a different test\"\n     *   errors that the developer isn't really responsible for. This can happen when a test\n     *   correctly schedules a call to release(), but also causes an uncaught error. The\n     *   uncaught error means we will no longer wait for the release (as it might not arrive).\n     *\n     * - Pause is never released, or called an insufficient number of times.\n     *\n     *   Our timeout handler will kill the pause and resume test processing, basically\n     *   like internalRecover(), but for one pause instead of any/all.\n     *\n     *   Here, too, any late calls to resume() will be silently ignored to avoid\n     *   extra errors. We tolerate this since the original test will have already been\n     *   marked as failure.\n     *\n     *   TODO: QUnit 3 will enable timeouts by default <https://github.com/qunitjs/qunit/issues/1483>,\n     *   but right now a test will hang indefinitely if async pauses are not released,\n     *   unless QUnit.config.testTimeout or assert.timeout() is used.\n     *\n     * - Pause is spontaneously released during a different test,\n     *   or when no test is currently running.\n     *\n     *   This is close to impossible because this error only happens if the original test\n     *   succesfully finished first (since other failure scenarios kill pauses and ignore\n     *   late calls). It can happen if a test ended exactly as expected, but has some\n     *   external or shared state continuing to hold a reference to the release callback,\n     *   and either the same test scheduled another call to it in the future, or a later test\n     *   causes it to be called through some shared state.\n     *\n     * - Pause release() is called too often, during the same test.\n     *\n     *   This simply throws an error, after which uncaught error handling picks it up\n     *   and processing resumes.\n     *\n     * @param {number} [requiredCalls=1]\n     */\n    internalStop: function internalStop() {\n      var requiredCalls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      config.blocking = true;\n      var test = this;\n      var pauseId = this.nextPauseId++;\n      var pause = {\n        cancelled: false,\n        remaining: requiredCalls\n      };\n      test.pauses.set(pauseId, pause);\n\n      function release() {\n        if (pause.cancelled) {\n          return;\n        }\n\n        if (config.current === undefined) {\n          throw new Error('Unexpected release of async pause after tests finished.\\n' + \"> Test: \".concat(test.testName, \" [async #\").concat(pauseId, \"]\"));\n        }\n\n        if (config.current !== test) {\n          throw new Error('Unexpected release of async pause during a different test.\\n' + \"> Test: \".concat(test.testName, \" [async #\").concat(pauseId, \"]\"));\n        }\n\n        if (pause.remaining <= 0) {\n          throw new Error('Tried to release async pause that was already released.\\n' + \"> Test: \".concat(test.testName, \" [async #\").concat(pauseId, \"]\"));\n        } // The `requiredCalls` parameter exists to support `assert.async(count)`\n\n\n        pause.remaining--;\n\n        if (pause.remaining === 0) {\n          test.pauses.delete(pauseId);\n        }\n\n        internalStart(test);\n      } // Set a recovery timeout, if so configured.\n\n\n      if (setTimeout$1) {\n        var timeoutDuration;\n\n        if (typeof test.timeout === 'number') {\n          timeoutDuration = test.timeout;\n        } else if (typeof config.testTimeout === 'number') {\n          timeoutDuration = config.testTimeout;\n        }\n\n        if (typeof timeoutDuration === 'number' && timeoutDuration > 0) {\n          config.timeoutHandler = function (timeout) {\n            return function () {\n              config.timeout = null;\n              pause.cancelled = true;\n              test.pauses.delete(pauseId);\n              test.pushFailure(\"Test took longer than \".concat(timeout, \"ms; test timed out.\"), sourceFromStacktrace(2));\n              internalStart(test);\n            };\n          };\n\n          clearTimeout(config.timeout);\n          config.timeout = setTimeout$1(config.timeoutHandler(timeoutDuration), timeoutDuration);\n        }\n      }\n\n      return release;\n    },\n    resolvePromise: function resolvePromise(promise, phase) {\n      if (promise != null) {\n        var _test = this;\n\n        var then = promise.then;\n\n        if (typeof then === 'function') {\n          var resume = _test.internalStop();\n\n          var resolve = function resolve() {\n            resume();\n          };\n\n          if (config.notrycatch) {\n            then.call(promise, resolve);\n          } else {\n            var reject = function reject(error) {\n              var message = 'Promise rejected ' + (!phase ? 'during' : phase.replace(/Each$/, '')) + ' \"' + _test.testName + '\": ' + (error && error.message || error);\n\n              _test.pushFailure(message, extractStacktrace(error, 0)); // Else next test will carry the responsibility\n\n\n              saveGlobal(); // Unblock\n\n              internalRecover(_test);\n            };\n\n            then.call(promise, resolve, reject);\n          }\n        }\n      }\n    },\n    valid: function valid() {\n      // Internally-generated tests are always valid\n      if (this.callback && this.callback.validTest) {\n        return true;\n      }\n\n      function moduleChainIdMatch(testModule, selectedId) {\n        return (// undefined or empty array\n          !selectedId || !selectedId.length || inArray(testModule.moduleId, selectedId) || testModule.parentModule && moduleChainIdMatch(testModule.parentModule, selectedId)\n        );\n      }\n\n      if (!moduleChainIdMatch(this.module, config.moduleId)) {\n        return false;\n      }\n\n      if (config.testId && config.testId.length && !inArray(this.testId, config.testId)) {\n        return false;\n      }\n\n      function moduleChainNameMatch(testModule, selectedModule) {\n        if (!selectedModule) {\n          // undefined or empty string\n          return true;\n        }\n\n        var testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\n        if (testModuleName === selectedModule) {\n          return true;\n        } else if (testModule.parentModule) {\n          return moduleChainNameMatch(testModule.parentModule, selectedModule);\n        } else {\n          return false;\n        }\n      }\n\n      var selectedModule = config.module && config.module.toLowerCase();\n\n      if (!moduleChainNameMatch(this.module, selectedModule)) {\n        return false;\n      }\n\n      var filter = config.filter;\n\n      if (!filter) {\n        return true;\n      }\n\n      var regexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec(filter);\n      var fullName = this.module.name + ': ' + this.testName;\n      return regexFilter ? this.regexFilter(!!regexFilter[1], regexFilter[2], regexFilter[3], fullName) : this.stringFilter(filter, fullName);\n    },\n    regexFilter: function regexFilter(exclude, pattern, flags, fullName) {\n      var regex = new RegExp(pattern, flags);\n      var match = regex.test(fullName);\n      return match !== exclude;\n    },\n    stringFilter: function stringFilter(filter, fullName) {\n      filter = filter.toLowerCase();\n      fullName = fullName.toLowerCase();\n      var include = filter.charAt(0) !== '!';\n\n      if (!include) {\n        filter = filter.slice(1);\n      } // If the filter matches, we need to honour include\n\n\n      if (fullName.indexOf(filter) !== -1) {\n        return include;\n      } // Otherwise, do the opposite\n\n\n      return !include;\n    }\n  };\n  function pushFailure() {\n    if (!config.current) {\n      throw new Error('pushFailure() assertion outside test context, in ' + sourceFromStacktrace(2));\n    } // Gets current test obj\n\n\n    var currentTest = config.current;\n    return currentTest.pushFailure.apply(currentTest, arguments);\n  }\n\n  function saveGlobal() {\n    config.pollution = [];\n\n    if (config.noglobals) {\n      for (var key in g) {\n        if (hasOwn$1.call(g, key)) {\n          // In Opera sometimes DOM element ids show up here, ignore them\n          if (/^qunit-test-output/.test(key)) {\n            continue;\n          }\n\n          config.pollution.push(key);\n        }\n      }\n    }\n  }\n\n  function checkPollution() {\n    var old = config.pollution;\n    saveGlobal();\n    var newGlobals = diff(config.pollution, old);\n\n    if (newGlobals.length > 0) {\n      pushFailure('Introduced global variable(s): ' + newGlobals.join(', '));\n    }\n\n    var deletedGlobals = diff(old, config.pollution);\n\n    if (deletedGlobals.length > 0) {\n      pushFailure('Deleted global variable(s): ' + deletedGlobals.join(', '));\n    }\n  }\n\n  var focused = false; // indicates that the \"only\" filter was used\n\n  function addTest(settings) {\n    if (focused || config.currentModule.ignored) {\n      return;\n    }\n\n    var newTest = new Test(settings);\n    newTest.queue();\n  }\n\n  function addOnlyTest(settings) {\n    if (config.currentModule.ignored) {\n      return;\n    }\n\n    if (!focused) {\n      config.queue.length = 0;\n      focused = true;\n    }\n\n    var newTest = new Test(settings);\n    newTest.queue();\n  } // Will be exposed as QUnit.test\n\n\n  function test(testName, callback) {\n    addTest({\n      testName: testName,\n      callback: callback\n    });\n  }\n\n  function makeEachTestName(testName, argument) {\n    return \"\".concat(testName, \" [\").concat(argument, \"]\");\n  }\n\n  function runEach(data, eachFn) {\n    if (Array.isArray(data)) {\n      for (var i = 0; i < data.length; i++) {\n        eachFn(data[i], i);\n      }\n    } else if (_typeof(data) === 'object' && data !== null) {\n      for (var key in data) {\n        eachFn(data[key], key);\n      }\n    } else {\n      throw new Error(\"test.each() expects an array or object as input, but\\nfound \".concat(_typeof(data), \" instead.\"));\n    }\n  }\n\n  extend(test, {\n    todo: function todo(testName, callback) {\n      addTest({\n        testName: testName,\n        callback: callback,\n        todo: true\n      });\n    },\n    skip: function skip(testName) {\n      addTest({\n        testName: testName,\n        skip: true\n      });\n    },\n    only: function only(testName, callback) {\n      addOnlyTest({\n        testName: testName,\n        callback: callback\n      });\n    },\n    each: function each(testName, dataset, callback) {\n      runEach(dataset, function (data, testKey) {\n        addTest({\n          testName: makeEachTestName(testName, testKey),\n          callback: callback,\n          withData: true,\n          stackOffset: 5,\n          data: data\n        });\n      });\n    }\n  });\n\n  test.todo.each = function (testName, dataset, callback) {\n    runEach(dataset, function (data, testKey) {\n      addTest({\n        testName: makeEachTestName(testName, testKey),\n        callback: callback,\n        todo: true,\n        withData: true,\n        stackOffset: 5,\n        data: data\n      });\n    });\n  };\n\n  test.skip.each = function (testName, dataset) {\n    runEach(dataset, function (_, testKey) {\n      addTest({\n        testName: makeEachTestName(testName, testKey),\n        stackOffset: 5,\n        skip: true\n      });\n    });\n  };\n\n  test.only.each = function (testName, dataset, callback) {\n    runEach(dataset, function (data, testKey) {\n      addOnlyTest({\n        testName: makeEachTestName(testName, testKey),\n        callback: callback,\n        withData: true,\n        stackOffset: 5,\n        data: data\n      });\n    });\n  }; // Forcefully release all processing holds.\n\n\n  function internalRecover(test) {\n    test.pauses.forEach(function (pause) {\n      pause.cancelled = true;\n    });\n    test.pauses.clear();\n    internalStart(test);\n  } // Release a processing hold, scheduling a resumption attempt if no holds remain.\n\n\n  function internalStart(test) {\n    // Ignore if other async pauses still exist.\n    if (test.pauses.size > 0) {\n      return;\n    } // Add a slight delay to allow more assertions etc.\n\n\n    if (setTimeout$1) {\n      clearTimeout(config.timeout);\n      config.timeout = setTimeout$1(function () {\n        if (test.pauses.size > 0) {\n          return;\n        }\n\n        clearTimeout(config.timeout);\n        config.timeout = null;\n        config.blocking = false;\n        ProcessingQueue.advance();\n      });\n    } else {\n      config.blocking = false;\n      ProcessingQueue.advance();\n    }\n  }\n\n  function collectTests(module) {\n    var tests = [].concat(module.tests);\n\n    var modules = _toConsumableArray(module.childModules); // Do a breadth-first traversal of the child modules\n\n\n    while (modules.length) {\n      var nextModule = modules.shift();\n      tests.push.apply(tests, nextModule.tests);\n      modules.push.apply(modules, _toConsumableArray(nextModule.childModules));\n    }\n\n    return tests;\n  } // This returns true after all executable and skippable tests\n  // in a module have been proccessed, and informs 'suiteEnd'\n  // and moduleDone().\n\n\n  function allTestsExecuted(module) {\n    return module.testsRun + module.testsIgnored === collectTests(module).length;\n  } // This returns true during the last executable non-skipped test\n  // within a module, and informs the running of the 'after' hook\n  // for a given module. This runs only once for a given module,\n  // but must run during the last non-skipped test. When it runs,\n  // there may be non-zero skipped tests left.\n\n\n  function lastTestWithinModuleExecuted(module) {\n    return module.testsRun === collectTests(module).filter(function (test) {\n      return !test.skip;\n    }).length - 1;\n  }\n\n  function incrementTestsRun(module) {\n    module.testsRun++;\n\n    while (module = module.parentModule) {\n      module.testsRun++;\n    }\n  }\n\n  function incrementTestsIgnored(module) {\n    module.testsIgnored++;\n\n    while (module = module.parentModule) {\n      module.testsIgnored++;\n    }\n  }\n\n  /* global module, exports, define */\n  function exportQUnit(QUnit) {\n    var exportedModule = false;\n\n    if (window$1 && document) {\n      // QUnit may be defined when it is preconfigured but then only QUnit and QUnit.config may be defined.\n      if (window$1.QUnit && window$1.QUnit.version) {\n        throw new Error('QUnit has already been defined.');\n      }\n\n      window$1.QUnit = QUnit;\n      exportedModule = true;\n    } // For Node.js\n\n\n    if ( true && module && module.exports) {\n      module.exports = QUnit; // For consistency with CommonJS environments' exports\n\n      module.exports.QUnit = QUnit;\n      exportedModule = true;\n    } // For CommonJS with exports, but without module.exports, like Rhino\n\n\n    if ( true && exports) {\n      exports.QUnit = QUnit;\n      exportedModule = true;\n    } // For AMD\n\n\n    if (true) {\n      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n        return QUnit;\n      }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      QUnit.config.autostart = false;\n      exportedModule = true;\n    } // For other environments, including Web Workers (globalThis === self),\n    // SpiderMonkey (mozjs), and other embedded JavaScript engines\n\n\n    if (!exportedModule) {\n      g.QUnit = QUnit;\n    }\n  }\n\n  var ConsoleReporter = /*#__PURE__*/function () {\n    function ConsoleReporter(runner) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, ConsoleReporter);\n\n      // Cache references to console methods to ensure we can report failures\n      // from tests tests that mock the console object itself.\n      // https://github.com/qunitjs/qunit/issues/1340\n      // Support IE 9: Function#bind is supported, but no console.log.bind().\n      this.log = options.log || Function.prototype.bind.call(console$1.log, console$1);\n      runner.on('error', this.onError.bind(this));\n      runner.on('runStart', this.onRunStart.bind(this));\n      runner.on('testStart', this.onTestStart.bind(this));\n      runner.on('testEnd', this.onTestEnd.bind(this));\n      runner.on('runEnd', this.onRunEnd.bind(this));\n    }\n\n    _createClass(ConsoleReporter, [{\n      key: \"onError\",\n      value: function onError(error) {\n        this.log('error', error);\n      }\n    }, {\n      key: \"onRunStart\",\n      value: function onRunStart(runStart) {\n        this.log('runStart', runStart);\n      }\n    }, {\n      key: \"onTestStart\",\n      value: function onTestStart(test) {\n        this.log('testStart', test);\n      }\n    }, {\n      key: \"onTestEnd\",\n      value: function onTestEnd(test) {\n        this.log('testEnd', test);\n      }\n    }, {\n      key: \"onRunEnd\",\n      value: function onRunEnd(runEnd) {\n        this.log('runEnd', runEnd);\n      }\n    }], [{\n      key: \"init\",\n      value: function init(runner, options) {\n        return new ConsoleReporter(runner, options);\n      }\n    }]);\n\n    return ConsoleReporter;\n  }();\n\n  var FORCE_COLOR,\n      NODE_DISABLE_COLORS,\n      NO_COLOR,\n      TERM,\n      isTTY = true;\n\n  if (typeof process !== 'undefined') {\n    var _process$env = process.env;\n    FORCE_COLOR = _process$env.FORCE_COLOR;\n    NODE_DISABLE_COLORS = _process$env.NODE_DISABLE_COLORS;\n    NO_COLOR = _process$env.NO_COLOR;\n    TERM = _process$env.TERM;\n    isTTY = process.stdout && process.stdout.isTTY;\n  }\n\n  var $ = {\n    enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY),\n    // modifiers\n    reset: init(0, 0),\n    bold: init(1, 22),\n    dim: init(2, 22),\n    italic: init(3, 23),\n    underline: init(4, 24),\n    inverse: init(7, 27),\n    hidden: init(8, 28),\n    strikethrough: init(9, 29),\n    // colors\n    black: init(30, 39),\n    red: init(31, 39),\n    green: init(32, 39),\n    yellow: init(33, 39),\n    blue: init(34, 39),\n    magenta: init(35, 39),\n    cyan: init(36, 39),\n    white: init(37, 39),\n    gray: init(90, 39),\n    grey: init(90, 39),\n    // background colors\n    bgBlack: init(40, 49),\n    bgRed: init(41, 49),\n    bgGreen: init(42, 49),\n    bgYellow: init(43, 49),\n    bgBlue: init(44, 49),\n    bgMagenta: init(45, 49),\n    bgCyan: init(46, 49),\n    bgWhite: init(47, 49)\n  };\n\n  function run(arr, str) {\n    var i = 0,\n        tmp,\n        beg = '',\n        end = '';\n\n    for (; i < arr.length; i++) {\n      tmp = arr[i];\n      beg += tmp.open;\n      end += tmp.close;\n\n      if (!!~str.indexOf(tmp.close)) {\n        str = str.replace(tmp.rgx, tmp.close + tmp.open);\n      }\n    }\n\n    return beg + str + end;\n  }\n\n  function chain(has, keys) {\n    var ctx = {\n      has: has,\n      keys: keys\n    };\n    ctx.reset = $.reset.bind(ctx);\n    ctx.bold = $.bold.bind(ctx);\n    ctx.dim = $.dim.bind(ctx);\n    ctx.italic = $.italic.bind(ctx);\n    ctx.underline = $.underline.bind(ctx);\n    ctx.inverse = $.inverse.bind(ctx);\n    ctx.hidden = $.hidden.bind(ctx);\n    ctx.strikethrough = $.strikethrough.bind(ctx);\n    ctx.black = $.black.bind(ctx);\n    ctx.red = $.red.bind(ctx);\n    ctx.green = $.green.bind(ctx);\n    ctx.yellow = $.yellow.bind(ctx);\n    ctx.blue = $.blue.bind(ctx);\n    ctx.magenta = $.magenta.bind(ctx);\n    ctx.cyan = $.cyan.bind(ctx);\n    ctx.white = $.white.bind(ctx);\n    ctx.gray = $.gray.bind(ctx);\n    ctx.grey = $.grey.bind(ctx);\n    ctx.bgBlack = $.bgBlack.bind(ctx);\n    ctx.bgRed = $.bgRed.bind(ctx);\n    ctx.bgGreen = $.bgGreen.bind(ctx);\n    ctx.bgYellow = $.bgYellow.bind(ctx);\n    ctx.bgBlue = $.bgBlue.bind(ctx);\n    ctx.bgMagenta = $.bgMagenta.bind(ctx);\n    ctx.bgCyan = $.bgCyan.bind(ctx);\n    ctx.bgWhite = $.bgWhite.bind(ctx);\n    return ctx;\n  }\n\n  function init(open, close) {\n    var blk = {\n      open: \"\\x1B[\".concat(open, \"m\"),\n      close: \"\\x1B[\".concat(close, \"m\"),\n      rgx: new RegExp(\"\\\\x1b\\\\[\".concat(close, \"m\"), 'g')\n    };\n    return function (txt) {\n      if (this !== void 0 && this.has !== void 0) {\n        !!~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));\n        return txt === void 0 ? this : $.enabled ? run(this.keys, txt + '') : txt + '';\n      }\n\n      return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt + '') : txt + '';\n    };\n  }\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  /**\n   * Format a given value into YAML.\n   *\n   * YAML is a superset of JSON that supports all the same data\n   * types and syntax, and more. As such, it is always possible\n   * to fallback to JSON.stringfify, but we generally avoid\n   * that to make output easier to read for humans.\n   *\n   * Supported data types:\n   *\n   * - null\n   * - boolean\n   * - number\n   * - string\n   * - array\n   * - object\n   *\n   * Anything else (including NaN, Infinity, and undefined)\n   * must be described in strings, for display purposes.\n   *\n   * Note that quotes are optional in YAML strings if the\n   * strings are \"simple\", and as such we generally prefer\n   * that for improved readability. We output strings in\n   * one of three ways:\n   *\n   * - bare unquoted text, for simple one-line strings.\n   * - JSON (quoted text), for complex one-line strings.\n   * - YAML Block, for complex multi-line strings.\n   *\n   * Objects with cyclical references will be stringifed as\n   * \"[Circular]\" as they cannot otherwise be represented.\n   */\n\n  function prettyYamlValue(value) {\n    var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n\n    if (value === undefined) {\n      // Not supported in JSON/YAML, turn into string\n      // and let the below output it as bare string.\n      value = String(value);\n    } // Support IE 9-11: Use isFinite instead of ES6 Number.isFinite\n\n\n    if (typeof value === 'number' && !isFinite(value)) {\n      // Turn NaN and Infinity into simple strings.\n      // Paranoia: Don't return directly just in case there's\n      // a way to add special characters here.\n      value = String(value);\n    }\n\n    if (typeof value === 'number') {\n      // Simple numbers\n      return JSON.stringify(value);\n    }\n\n    if (typeof value === 'string') {\n      // If any of these match, then we can't output it\n      // as bare unquoted text, because that would either\n      // cause data loss or invalid YAML syntax.\n      //\n      // - Quotes, escapes, line breaks, or JSON-like stuff.\n      var rSpecialJson = /['\"\\\\/[{}\\]\\r\\n]/; // - Characters that are special at the start of a YAML value\n\n      var rSpecialYaml = /[-?:,[\\]{}#&*!|=>'\"%@`]/; // - Leading or trailing whitespace.\n\n      var rUntrimmed = /(^\\s|\\s$)/; // - Ambiguous as YAML number, e.g. '2', '-1.2', '.2', or '2_000'\n\n      var rNumerical = /^[\\d._-]+$/; // - Ambiguous as YAML bool.\n      //   Use case-insensitive match, although technically only\n      //   fully-lower, fully-upper, or uppercase-first would be ambiguous.\n      //   e.g. true/True/TRUE, but not tRUe.\n\n      var rBool = /^(true|false|y|n|yes|no|on|off)$/i; // Is this a complex string?\n\n      if (value === '' || rSpecialJson.test(value) || rSpecialYaml.test(value[0]) || rUntrimmed.test(value) || rNumerical.test(value) || rBool.test(value)) {\n        if (!/\\n/.test(value)) {\n          // Complex one-line string, use JSON (quoted string)\n          return JSON.stringify(value);\n        } // See also <https://yaml-multiline.info/>\n        // Support IE 9-11: Avoid ES6 String#repeat\n\n\n        var prefix = new Array(indent + 1).join(' ');\n        var trailingLinebreakMatch = value.match(/\\n+$/);\n        var trailingLinebreaks = trailingLinebreakMatch ? trailingLinebreakMatch[0].length : 0;\n\n        if (trailingLinebreaks === 1) {\n          // Use the most straight-forward \"Block\" string in YAML\n          // without any \"Chomping\" indicators.\n          var lines = value // Ignore the last new line, since we'll get that one for free\n          // with the straight-forward Block syntax.\n          .replace(/\\n$/, '').split('\\n').map(function (line) {\n            return prefix + line;\n          });\n          return '|\\n' + lines.join('\\n');\n        } else {\n          // This has either no trailing new lines, or more than 1.\n          // Use |+ so that YAML parsers will preserve it exactly.\n          var _lines = value.split('\\n').map(function (line) {\n            return prefix + line;\n          });\n\n          return '|+\\n' + _lines.join('\\n');\n        }\n      } else {\n        // Simple string, use bare unquoted text\n        return value;\n      }\n    } // Handle null, boolean, array, and object\n\n\n    return JSON.stringify(decycledShallowClone(value), null, 2);\n  }\n  /**\n   * Creates a shallow clone of an object where cycles have\n   * been replaced with \"[Circular]\".\n   */\n\n\n  function decycledShallowClone(object) {\n    var ancestors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (ancestors.indexOf(object) !== -1) {\n      return '[Circular]';\n    }\n\n    var type = Object.prototype.toString.call(object).replace(/^\\[.+\\s(.+?)]$/, '$1').toLowerCase();\n    var clone;\n\n    switch (type) {\n      case 'array':\n        ancestors.push(object);\n        clone = object.map(function (element) {\n          return decycledShallowClone(element, ancestors);\n        });\n        ancestors.pop();\n        break;\n\n      case 'object':\n        ancestors.push(object);\n        clone = {};\n        Object.keys(object).forEach(function (key) {\n          clone[key] = decycledShallowClone(object[key], ancestors);\n        });\n        ancestors.pop();\n        break;\n\n      default:\n        clone = object;\n    }\n\n    return clone;\n  }\n\n  var TapReporter = /*#__PURE__*/function () {\n    function TapReporter(runner) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, TapReporter);\n\n      // Cache references to console methods to ensure we can report failures\n      // from tests tests that mock the console object itself.\n      // https://github.com/qunitjs/qunit/issues/1340\n      // Support IE 9: Function#bind is supported, but no console.log.bind().\n      this.log = options.log || Function.prototype.bind.call(console$1.log, console$1);\n      this.testCount = 0;\n      this.ended = false;\n      this.bailed = false;\n      runner.on('error', this.onError.bind(this));\n      runner.on('runStart', this.onRunStart.bind(this));\n      runner.on('testEnd', this.onTestEnd.bind(this));\n      runner.on('runEnd', this.onRunEnd.bind(this));\n    }\n\n    _createClass(TapReporter, [{\n      key: \"onRunStart\",\n      value: function onRunStart(_runSuite) {\n        this.log('TAP version 13');\n      }\n    }, {\n      key: \"onError\",\n      value: function onError(error) {\n        if (this.bailed) {\n          return;\n        }\n\n        this.bailed = true; // Imitate onTestEnd\n        // Skip this if we're past \"runEnd\" as it would look odd\n\n        if (!this.ended) {\n          this.testCount = this.testCount + 1;\n          this.log($.red(\"not ok \".concat(this.testCount, \" global failure\")));\n          this.logError(error);\n        }\n\n        this.log('Bail out! ' + errorString(error).split('\\n')[0]);\n\n        if (this.ended) {\n          this.logError(error);\n        }\n      }\n    }, {\n      key: \"onTestEnd\",\n      value: function onTestEnd(test) {\n        var _this = this;\n\n        this.testCount = this.testCount + 1;\n\n        if (test.status === 'passed') {\n          this.log(\"ok \".concat(this.testCount, \" \").concat(test.fullName.join(' > ')));\n        } else if (test.status === 'skipped') {\n          this.log($.yellow(\"ok \".concat(this.testCount, \" # SKIP \").concat(test.fullName.join(' > '))));\n        } else if (test.status === 'todo') {\n          this.log($.cyan(\"not ok \".concat(this.testCount, \" # TODO \").concat(test.fullName.join(' > '))));\n          test.errors.forEach(function (error) {\n            return _this.logAssertion(error, 'todo');\n          });\n        } else {\n          this.log($.red(\"not ok \".concat(this.testCount, \" \").concat(test.fullName.join(' > '))));\n          test.errors.forEach(function (error) {\n            return _this.logAssertion(error);\n          });\n        }\n      }\n    }, {\n      key: \"onRunEnd\",\n      value: function onRunEnd(runSuite) {\n        this.ended = true;\n        this.log(\"1..\".concat(runSuite.testCounts.total));\n        this.log(\"# pass \".concat(runSuite.testCounts.passed));\n        this.log($.yellow(\"# skip \".concat(runSuite.testCounts.skipped)));\n        this.log($.cyan(\"# todo \".concat(runSuite.testCounts.todo)));\n        this.log($.red(\"# fail \".concat(runSuite.testCounts.failed)));\n      }\n    }, {\n      key: \"logAssertion\",\n      value: function logAssertion(error, severity) {\n        var out = '  ---';\n        out += \"\\n  message: \".concat(prettyYamlValue(error.message || 'failed'));\n        out += \"\\n  severity: \".concat(prettyYamlValue(severity || 'failed'));\n\n        if (hasOwn.call(error, 'actual')) {\n          out += \"\\n  actual  : \".concat(prettyYamlValue(error.actual));\n        }\n\n        if (hasOwn.call(error, 'expected')) {\n          out += \"\\n  expected: \".concat(prettyYamlValue(error.expected));\n        }\n\n        if (error.stack) {\n          // Since stacks aren't user generated, take a bit of liberty by\n          // adding a trailing new line to allow a straight-forward YAML Blocks.\n          out += \"\\n  stack: \".concat(prettyYamlValue(error.stack + '\\n'));\n        }\n\n        out += '\\n  ...';\n        this.log(out);\n      }\n    }, {\n      key: \"logError\",\n      value: function logError(error) {\n        var out = '  ---';\n        out += \"\\n  message: \".concat(prettyYamlValue(errorString(error)));\n        out += \"\\n  severity: \".concat(prettyYamlValue('failed'));\n\n        if (error && error.stack) {\n          out += \"\\n  stack: \".concat(prettyYamlValue(error.stack + '\\n'));\n        }\n\n        out += '\\n  ...';\n        this.log(out);\n      }\n    }], [{\n      key: \"init\",\n      value: function init(runner, options) {\n        return new TapReporter(runner, options);\n      }\n    }]);\n\n    return TapReporter;\n  }();\n\n  var reporters = {\n    console: ConsoleReporter,\n    tap: TapReporter\n  };\n\n  function makeAddGlobalHook(hookName) {\n    return function addGlobalHook(callback) {\n      if (!config.globalHooks[hookName]) {\n        config.globalHooks[hookName] = [];\n      }\n\n      config.globalHooks[hookName].push(callback);\n    };\n  }\n\n  var hooks = {\n    beforeEach: makeAddGlobalHook('beforeEach'),\n    afterEach: makeAddGlobalHook('afterEach')\n  };\n\n  /**\n   * Handle a global error that should result in a failed test run.\n   *\n   * Summary:\n   *\n   * - If we're strictly inside a test (or one if its module hooks), the exception\n   *   becomes a failed assertion.\n   *\n   *   This has the important side-effect that uncaught exceptions (such as\n   *   calling an undefined function) during a \"todo\" test do NOT result in\n   *   a failed test run.\n   *\n   * - If we're anywhere outside a test (be it in early event callbacks, or\n   *   internally between tests, or somewhere after \"runEnd\" if the process is\n   *   still alive for some reason), then send an \"error\" event to the reporters.\n   *\n   * @since 2.17.0\n   * @param {Error|any} error\n   */\n\n  function onUncaughtException(error) {\n    if (config.current) {\n      config.current.assert.pushResult({\n        result: false,\n        message: \"global failure: \".concat(errorString(error)),\n        // We could let callers specify an offset to subtract a number of frames via\n        // sourceFromStacktrace, in case they are a wrapper further away from the error\n        // handler, and thus reduce some noise in the stack trace. However, we're not\n        // doing this right now because it would almost never be used in practice given\n        // the vast majority of error values will be Error objects, and thus have their\n        // own stack trace already.\n        source: error && error.stack || sourceFromStacktrace(2)\n      });\n    } else {\n      // The \"error\" event was added in QUnit 2.17.\n      // Increase \"bad assertion\" stats despite no longer pushing an assertion in this case.\n      // This ensures \"runEnd\" and \"QUnit.done()\" handlers behave as expected, since the \"bad\"\n      // count is typically how reporters decide on the boolean outcome of the test run.\n      runSuite.globalFailureCount++;\n      config.stats.bad++;\n      config.stats.all++;\n      emit('error', error);\n    }\n  }\n\n  /**\n   * Handle a window.onerror error.\n   *\n   * If there is a current test that sets the internal `ignoreGlobalErrors` field\n   * (such as during `assert.throws()`), then the error is ignored and native\n   * error reporting is suppressed as well. This is because in browsers, an error\n   * can sometimes end up in `window.onerror` instead of in the local try/catch.\n   * This ignoring of errors does not apply to our general onUncaughtException\n   * method, nor to our `unhandledRejection` handlers, as those are not meant\n   * to receive an \"expected\" error during `assert.throws()`.\n   *\n   * @see <https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror>\n   * @deprecated since 2.17.0 Use QUnit.onUncaughtException instead.\n   * @param {Object} details\n   * @param {string} details.message\n   * @param {string} details.fileName\n   * @param {number} details.lineNumber\n   * @param {string|undefined} [details.stacktrace]\n   * @return {bool} True if native error reporting should be suppressed.\n   */\n\n  function onWindowError(details) {\n    Logger.warn('QUnit.onError is deprecated and will be removed in QUnit 3.0.' + ' Please use QUnit.onUncaughtException instead.');\n\n    if (config.current && config.current.ignoreGlobalErrors) {\n      return true;\n    }\n\n    var err = new Error(details.message);\n    err.stack = details.stacktrace || details.fileName + ':' + details.lineNumber;\n    onUncaughtException(err);\n    return false;\n  }\n\n  var QUnit = {}; // The \"currentModule\" object would ideally be defined using the createModule()\n  // function. Since it isn't, add the missing suiteReport property to it now that\n  // we have loaded all source code required to do so.\n  //\n  // TODO: Consider defining currentModule in core.js or module.js in its entirely\n  // rather than partly in config.js and partly here.\n\n  config.currentModule.suiteReport = runSuite;\n  var globalStartCalled = false;\n  var runStarted = false; // Figure out if we're running the tests from a server or not\n\n  QUnit.isLocal = window$1 && window$1.location && window$1.location.protocol === 'file:'; // Expose the current QUnit version\n\n  QUnit.version = '2.19.1';\n\n  extend(QUnit, {\n    config: config,\n    dump: dump,\n    equiv: equiv,\n    reporters: reporters,\n    hooks: hooks,\n    is: is,\n    objectType: objectType,\n    on: on,\n    onError: onWindowError,\n    onUncaughtException: onUncaughtException,\n    pushFailure: pushFailure,\n    assert: Assert.prototype,\n    module: module$1,\n    test: test,\n    // alias other test flavors for easy access\n    todo: test.todo,\n    skip: test.skip,\n    only: test.only,\n    start: function start(count) {\n      if (config.current) {\n        throw new Error('QUnit.start cannot be called inside a test context.');\n      }\n\n      var globalStartAlreadyCalled = globalStartCalled;\n      globalStartCalled = true;\n\n      if (runStarted) {\n        throw new Error('Called start() while test already started running');\n      }\n\n      if (globalStartAlreadyCalled || count > 1) {\n        throw new Error('Called start() outside of a test context too many times');\n      }\n\n      if (config.autostart) {\n        throw new Error('Called start() outside of a test context when ' + 'QUnit.config.autostart was true');\n      }\n\n      if (!config.pageLoaded) {\n        // The page isn't completely loaded yet, so we set autostart and then\n        // load if we're in Node or wait for the browser's load event.\n        config.autostart = true; // Starts from Node even if .load was not previously called. We still return\n        // early otherwise we'll wind up \"beginning\" twice.\n\n        if (!document) {\n          QUnit.load();\n        }\n\n        return;\n      }\n\n      scheduleBegin();\n    },\n    onUnhandledRejection: function onUnhandledRejection(reason) {\n      Logger.warn('QUnit.onUnhandledRejection is deprecated and will be removed in QUnit 3.0.' + ' Please use QUnit.onUncaughtException instead.');\n      onUncaughtException(reason);\n    },\n    extend: function extend$1() {\n      Logger.warn('QUnit.extend is deprecated and will be removed in QUnit 3.0.' + ' Please use Object.assign instead.'); // delegate to utility implementation, which does not warn and can be used elsewhere internally\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return extend.apply(this, args);\n    },\n    load: function load() {\n      config.pageLoaded = true; // Initialize the configuration options\n\n      extend(config, {\n        started: 0,\n        updateRate: 1000,\n        autostart: true,\n        filter: ''\n      }, true);\n\n      if (!runStarted) {\n        config.blocking = false;\n\n        if (config.autostart) {\n          scheduleBegin();\n        }\n      }\n    },\n    stack: function stack(offset) {\n      offset = (offset || 0) + 2;\n      return sourceFromStacktrace(offset);\n    }\n  });\n\n  registerLoggingCallbacks(QUnit);\n\n  function scheduleBegin() {\n    runStarted = true; // Add a slight delay to allow definition of more modules and tests.\n\n    if (setTimeout$1) {\n      setTimeout$1(function () {\n        begin();\n      });\n    } else {\n      begin();\n    }\n  }\n\n  function unblockAndAdvanceQueue() {\n    config.blocking = false;\n    ProcessingQueue.advance();\n  }\n\n  function begin() {\n    if (config.started) {\n      unblockAndAdvanceQueue();\n      return;\n    } // The test run hasn't officially begun yet\n    // Record the time of the test run's beginning\n\n\n    config.started = performance.now(); // Delete the loose unnamed module if unused.\n\n    if (config.modules[0].name === '' && config.modules[0].tests.length === 0) {\n      config.modules.shift();\n    }\n\n    var modulesLog = [];\n\n    for (var i = 0; i < config.modules.length; i++) {\n      // Don't expose the unnamed global test module to plugins.\n      if (config.modules[i].name !== '') {\n        modulesLog.push({\n          name: config.modules[i].name,\n          moduleId: config.modules[i].moduleId,\n          // Added in QUnit 1.16.0 for internal use by html-reporter,\n          // but no longer used since QUnit 2.7.0.\n          // @deprecated Kept unofficially to be removed in QUnit 3.0.\n          tests: config.modules[i].tests\n        });\n      }\n    } // The test run is officially beginning now\n\n\n    emit('runStart', runSuite.start(true));\n    runLoggingCallbacks('begin', {\n      totalTests: Test.count,\n      modules: modulesLog\n    }).then(unblockAndAdvanceQueue);\n  }\n  exportQUnit(QUnit);\n\n  (function () {\n    if (!window$1 || !document) {\n      return;\n    }\n\n    var config = QUnit.config;\n    var hasOwn = Object.prototype.hasOwnProperty; // Stores fixture HTML for resetting later\n\n    function storeFixture() {\n      // Avoid overwriting user-defined values\n      if (hasOwn.call(config, 'fixture')) {\n        return;\n      }\n\n      var fixture = document.getElementById('qunit-fixture');\n\n      if (fixture) {\n        config.fixture = fixture.cloneNode(true);\n      }\n    }\n\n    QUnit.begin(storeFixture); // Resets the fixture DOM element if available.\n\n    function resetFixture() {\n      if (config.fixture == null) {\n        return;\n      }\n\n      var fixture = document.getElementById('qunit-fixture');\n\n      var resetFixtureType = _typeof(config.fixture);\n\n      if (resetFixtureType === 'string') {\n        // support user defined values for `config.fixture`\n        var newFixture = document.createElement('div');\n        newFixture.setAttribute('id', 'qunit-fixture');\n        newFixture.innerHTML = config.fixture;\n        fixture.parentNode.replaceChild(newFixture, fixture);\n      } else {\n        var clonedFixture = config.fixture.cloneNode(true);\n        fixture.parentNode.replaceChild(clonedFixture, fixture);\n      }\n    }\n\n    QUnit.testStart(resetFixture);\n  })();\n\n  (function () {\n    // Only interact with URLs via window.location\n    var location = typeof window$1 !== 'undefined' && window$1.location;\n\n    if (!location) {\n      return;\n    }\n\n    var urlParams = getUrlParams();\n    QUnit.urlParams = urlParams;\n    QUnit.config.filter = urlParams.filter;\n    QUnit.config.module = urlParams.module;\n    QUnit.config.moduleId = [].concat(urlParams.moduleId || []);\n    QUnit.config.testId = [].concat(urlParams.testId || []); // Test order randomization\n\n    if (urlParams.seed === true) {\n      // Generate a random seed if the option is specified without a value\n      QUnit.config.seed = Math.random().toString(36).slice(2);\n    } else if (urlParams.seed) {\n      QUnit.config.seed = urlParams.seed;\n    } // Add URL-parameter-mapped config values with UI form rendering data\n\n\n    QUnit.config.urlConfig.push({\n      id: 'hidepassed',\n      label: 'Hide passed tests',\n      tooltip: 'Only show tests and assertions that fail. Stored as query-strings.'\n    }, {\n      id: 'noglobals',\n      label: 'Check for Globals',\n      tooltip: 'Enabling this will test if any test introduces new properties on the ' + 'global object (`window` in Browsers). Stored as query-strings.'\n    }, {\n      id: 'notrycatch',\n      label: 'No try-catch',\n      tooltip: 'Enabling this will run tests outside of a try-catch block. Makes debugging ' + 'exceptions in IE reasonable. Stored as query-strings.'\n    });\n    QUnit.begin(function () {\n      var urlConfig = QUnit.config.urlConfig;\n\n      for (var i = 0; i < urlConfig.length; i++) {\n        // Options can be either strings or objects with nonempty \"id\" properties\n        var option = QUnit.config.urlConfig[i];\n\n        if (typeof option !== 'string') {\n          option = option.id;\n        }\n\n        if (QUnit.config[option] === undefined) {\n          QUnit.config[option] = urlParams[option];\n        }\n      }\n    });\n\n    function getUrlParams() {\n      var urlParams = Object.create(null);\n      var params = location.search.slice(1).split('&');\n      var length = params.length;\n\n      for (var i = 0; i < length; i++) {\n        if (params[i]) {\n          var param = params[i].split('=');\n          var name = decodeQueryParam(param[0]); // Allow just a key to turn on a flag, e.g., test.html?noglobals\n\n          var value = param.length === 1 || decodeQueryParam(param.slice(1).join('='));\n\n          if (name in urlParams) {\n            urlParams[name] = [].concat(urlParams[name], value);\n          } else {\n            urlParams[name] = value;\n          }\n        }\n      }\n\n      return urlParams;\n    }\n\n    function decodeQueryParam(param) {\n      return decodeURIComponent(param.replace(/\\+/g, '%20'));\n    }\n  })();\n\n  var fuzzysort$1 = {exports: {}};\n\n  (function (module) {\n\n    (function (root, UMD) {\n      if (module.exports) module.exports = UMD();else root.fuzzysort = UMD();\n    })(commonjsGlobal, function UMD() {\n      function fuzzysortNew(instanceOptions) {\n        var fuzzysort = {\n          single: function single(search, target, options) {\n            if (search == 'farzher') return {\n              target: \"farzher was here (^-^*)/\",\n              score: 0,\n              indexes: [0, 1, 2, 3, 4, 5, 6]\n            };\n            if (!search) return null;\n            if (!isObj(search)) search = fuzzysort.getPreparedSearch(search);\n            if (!target) return null;\n            if (!isObj(target)) target = fuzzysort.getPrepared(target);\n            var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n            var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n            return algorithm(search, target, search[0]);\n          },\n          go: function go(search, targets, options) {\n            if (search == 'farzher') return [{\n              target: \"farzher was here (^-^*)/\",\n              score: 0,\n              indexes: [0, 1, 2, 3, 4, 5, 6],\n              obj: targets ? targets[0] : null\n            }];\n            if (!search) return noResults;\n            search = fuzzysort.prepareSearch(search);\n            var searchLowerCode = search[0];\n            var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;\n            var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;\n            var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n            var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n            var resultsLen = 0;\n            var limitedCount = 0;\n            var targetsLen = targets.length; // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n            // options.keys\n\n            if (options && options.keys) {\n              var scoreFn = options.scoreFn || defaultScoreFn;\n              var keys = options.keys;\n              var keysLen = keys.length;\n\n              for (var i = targetsLen - 1; i >= 0; --i) {\n                var obj = targets[i];\n                var objResults = new Array(keysLen);\n\n                for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\n                  var key = keys[keyI];\n                  var target = getValue(obj, key);\n\n                  if (!target) {\n                    objResults[keyI] = null;\n                    continue;\n                  }\n\n                  if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                  objResults[keyI] = algorithm(search, target, searchLowerCode);\n                }\n\n                objResults.obj = obj; // before scoreFn so scoreFn can use it\n\n                var score = scoreFn(objResults);\n                if (score === null) continue;\n                if (score < threshold) continue;\n                objResults.score = score;\n\n                if (resultsLen < limit) {\n                  q.add(objResults);\n                  ++resultsLen;\n                } else {\n                  ++limitedCount;\n                  if (score > q.peek().score) q.replaceTop(objResults);\n                }\n              } // options.key\n\n            } else if (options && options.key) {\n              var key = options.key;\n\n              for (var i = targetsLen - 1; i >= 0; --i) {\n                var obj = targets[i];\n                var target = getValue(obj, key);\n                if (!target) continue;\n                if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                var result = algorithm(search, target, searchLowerCode);\n                if (result === null) continue;\n                if (result.score < threshold) continue; // have to clone result so duplicate targets from different obj can each reference the correct obj\n\n                result = {\n                  target: result.target,\n                  _targetLowerCodes: null,\n                  _nextBeginningIndexes: null,\n                  score: result.score,\n                  indexes: result.indexes,\n                  obj: obj\n                }; // hidden\n\n                if (resultsLen < limit) {\n                  q.add(result);\n                  ++resultsLen;\n                } else {\n                  ++limitedCount;\n                  if (result.score > q.peek().score) q.replaceTop(result);\n                }\n              } // no keys\n\n            } else {\n              for (var i = targetsLen - 1; i >= 0; --i) {\n                var target = targets[i];\n                if (!target) continue;\n                if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                var result = algorithm(search, target, searchLowerCode);\n                if (result === null) continue;\n                if (result.score < threshold) continue;\n\n                if (resultsLen < limit) {\n                  q.add(result);\n                  ++resultsLen;\n                } else {\n                  ++limitedCount;\n                  if (result.score > q.peek().score) q.replaceTop(result);\n                }\n              }\n            }\n\n            if (resultsLen === 0) return noResults;\n            var results = new Array(resultsLen);\n\n            for (var i = resultsLen - 1; i >= 0; --i) {\n              results[i] = q.poll();\n            }\n\n            results.total = resultsLen + limitedCount;\n            return results;\n          },\n          goAsync: function goAsync(search, targets, options) {\n            var canceled = false;\n            var p = new Promise(function (resolve, reject) {\n              if (search == 'farzher') return resolve([{\n                target: \"farzher was here (^-^*)/\",\n                score: 0,\n                indexes: [0, 1, 2, 3, 4, 5, 6],\n                obj: targets ? targets[0] : null\n              }]);\n              if (!search) return resolve(noResults);\n              search = fuzzysort.prepareSearch(search);\n              var searchLowerCode = search[0];\n              var q = fastpriorityqueue();\n              var iCurrent = targets.length - 1;\n              var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;\n              var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;\n              var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n              var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n              var resultsLen = 0;\n              var limitedCount = 0;\n\n              function step() {\n                if (canceled) return reject('canceled');\n                var startMs = Date.now(); // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n                // options.keys\n\n                if (options && options.keys) {\n                  var scoreFn = options.scoreFn || defaultScoreFn;\n                  var keys = options.keys;\n                  var keysLen = keys.length;\n\n                  for (; iCurrent >= 0; --iCurrent) {\n                    if (iCurrent % 1000\n                    /*itemsPerCheck*/\n                    === 0) {\n                      if (Date.now() - startMs >= 10\n                      /*asyncInterval*/\n                      ) {\n                        isNode ? setImmediate(step) : setTimeout(step);\n                        return;\n                      }\n                    }\n\n                    var obj = targets[iCurrent];\n                    var objResults = new Array(keysLen);\n\n                    for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\n                      var key = keys[keyI];\n                      var target = getValue(obj, key);\n\n                      if (!target) {\n                        objResults[keyI] = null;\n                        continue;\n                      }\n\n                      if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                      objResults[keyI] = algorithm(search, target, searchLowerCode);\n                    }\n\n                    objResults.obj = obj; // before scoreFn so scoreFn can use it\n\n                    var score = scoreFn(objResults);\n                    if (score === null) continue;\n                    if (score < threshold) continue;\n                    objResults.score = score;\n\n                    if (resultsLen < limit) {\n                      q.add(objResults);\n                      ++resultsLen;\n                    } else {\n                      ++limitedCount;\n                      if (score > q.peek().score) q.replaceTop(objResults);\n                    }\n                  } // options.key\n\n                } else if (options && options.key) {\n                  var key = options.key;\n\n                  for (; iCurrent >= 0; --iCurrent) {\n                    if (iCurrent % 1000\n                    /*itemsPerCheck*/\n                    === 0) {\n                      if (Date.now() - startMs >= 10\n                      /*asyncInterval*/\n                      ) {\n                        isNode ? setImmediate(step) : setTimeout(step);\n                        return;\n                      }\n                    }\n\n                    var obj = targets[iCurrent];\n                    var target = getValue(obj, key);\n                    if (!target) continue;\n                    if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                    var result = algorithm(search, target, searchLowerCode);\n                    if (result === null) continue;\n                    if (result.score < threshold) continue; // have to clone result so duplicate targets from different obj can each reference the correct obj\n\n                    result = {\n                      target: result.target,\n                      _targetLowerCodes: null,\n                      _nextBeginningIndexes: null,\n                      score: result.score,\n                      indexes: result.indexes,\n                      obj: obj\n                    }; // hidden\n\n                    if (resultsLen < limit) {\n                      q.add(result);\n                      ++resultsLen;\n                    } else {\n                      ++limitedCount;\n                      if (result.score > q.peek().score) q.replaceTop(result);\n                    }\n                  } // no keys\n\n                } else {\n                  for (; iCurrent >= 0; --iCurrent) {\n                    if (iCurrent % 1000\n                    /*itemsPerCheck*/\n                    === 0) {\n                      if (Date.now() - startMs >= 10\n                      /*asyncInterval*/\n                      ) {\n                        isNode ? setImmediate(step) : setTimeout(step);\n                        return;\n                      }\n                    }\n\n                    var target = targets[iCurrent];\n                    if (!target) continue;\n                    if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                    var result = algorithm(search, target, searchLowerCode);\n                    if (result === null) continue;\n                    if (result.score < threshold) continue;\n\n                    if (resultsLen < limit) {\n                      q.add(result);\n                      ++resultsLen;\n                    } else {\n                      ++limitedCount;\n                      if (result.score > q.peek().score) q.replaceTop(result);\n                    }\n                  }\n                }\n\n                if (resultsLen === 0) return resolve(noResults);\n                var results = new Array(resultsLen);\n\n                for (var i = resultsLen - 1; i >= 0; --i) {\n                  results[i] = q.poll();\n                }\n\n                results.total = resultsLen + limitedCount;\n                resolve(results);\n              }\n\n              isNode ? setImmediate(step) : step(); //setTimeout here is too slow\n            });\n\n            p.cancel = function () {\n              canceled = true;\n            };\n\n            return p;\n          },\n          highlight: function highlight(result, hOpen, hClose) {\n            if (typeof hOpen == 'function') return fuzzysort.highlightCallback(result, hOpen);\n            if (result === null) return null;\n            if (hOpen === undefined) hOpen = '<b>';\n            if (hClose === undefined) hClose = '</b>';\n            var highlighted = '';\n            var matchesIndex = 0;\n            var opened = false;\n            var target = result.target;\n            var targetLen = target.length;\n            var matchesBest = result.indexes;\n\n            for (var i = 0; i < targetLen; ++i) {\n              var char = target[i];\n\n              if (matchesBest[matchesIndex] === i) {\n                ++matchesIndex;\n\n                if (!opened) {\n                  opened = true;\n                  highlighted += hOpen;\n                }\n\n                if (matchesIndex === matchesBest.length) {\n                  highlighted += char + hClose + target.substr(i + 1);\n                  break;\n                }\n              } else {\n                if (opened) {\n                  opened = false;\n                  highlighted += hClose;\n                }\n              }\n\n              highlighted += char;\n            }\n\n            return highlighted;\n          },\n          highlightCallback: function highlightCallback(result, cb) {\n            if (result === null) return null;\n            var target = result.target;\n            var targetLen = target.length;\n            var indexes = result.indexes;\n            var highlighted = '';\n            var matchI = 0;\n            var indexesI = 0;\n            var opened = false;\n            var result = [];\n\n            for (var i = 0; i < targetLen; ++i) {\n              var char = target[i];\n\n              if (indexes[indexesI] === i) {\n                ++indexesI;\n\n                if (!opened) {\n                  opened = true;\n                  result.push(highlighted);\n                  highlighted = '';\n                }\n\n                if (indexesI === indexes.length) {\n                  highlighted += char;\n                  result.push(cb(highlighted, matchI++));\n                  highlighted = '';\n                  result.push(target.substr(i + 1));\n                  break;\n                }\n              } else {\n                if (opened) {\n                  opened = false;\n                  result.push(cb(highlighted, matchI++));\n                  highlighted = '';\n                }\n              }\n\n              highlighted += char;\n            }\n\n            return result;\n          },\n          prepare: function prepare(target) {\n            if (!target) return {\n              target: '',\n              _targetLowerCodes: [0\n              /*this 0 doesn't make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/\n              ],\n              _nextBeginningIndexes: null,\n              score: null,\n              indexes: null,\n              obj: null\n            }; // hidden\n\n            return {\n              target: target,\n              _targetLowerCodes: fuzzysort.prepareLowerCodes(target),\n              _nextBeginningIndexes: null,\n              score: null,\n              indexes: null,\n              obj: null\n            }; // hidden\n          },\n          prepareSlow: function prepareSlow(target) {\n            if (!target) return {\n              target: '',\n              _targetLowerCodes: [0\n              /*this 0 doesn't make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/\n              ],\n              _nextBeginningIndexes: null,\n              score: null,\n              indexes: null,\n              obj: null\n            }; // hidden\n\n            return {\n              target: target,\n              _targetLowerCodes: fuzzysort.prepareLowerCodes(target),\n              _nextBeginningIndexes: fuzzysort.prepareNextBeginningIndexes(target),\n              score: null,\n              indexes: null,\n              obj: null\n            }; // hidden\n          },\n          prepareSearch: function prepareSearch(search) {\n            if (!search) search = '';\n            return fuzzysort.prepareLowerCodes(search);\n          },\n          // Below this point is only internal code\n          // Below this point is only internal code\n          // Below this point is only internal code\n          // Below this point is only internal code\n          getPrepared: function getPrepared(target) {\n            if (target.length > 999) return fuzzysort.prepare(target); // don't cache huge targets\n\n            var targetPrepared = preparedCache.get(target);\n            if (targetPrepared !== undefined) return targetPrepared;\n            targetPrepared = fuzzysort.prepare(target);\n            preparedCache.set(target, targetPrepared);\n            return targetPrepared;\n          },\n          getPreparedSearch: function getPreparedSearch(search) {\n            if (search.length > 999) return fuzzysort.prepareSearch(search); // don't cache huge searches\n\n            var searchPrepared = preparedSearchCache.get(search);\n            if (searchPrepared !== undefined) return searchPrepared;\n            searchPrepared = fuzzysort.prepareSearch(search);\n            preparedSearchCache.set(search, searchPrepared);\n            return searchPrepared;\n          },\n          algorithm: function algorithm(searchLowerCodes, prepared, searchLowerCode) {\n            var targetLowerCodes = prepared._targetLowerCodes;\n            var searchLen = searchLowerCodes.length;\n            var targetLen = targetLowerCodes.length;\n            var searchI = 0; // where we at\n\n            var targetI = 0; // where you at\n\n            var typoSimpleI = 0;\n            var matchesSimpleLen = 0; // very basic fuzzy match; to remove non-matching targets ASAP!\n            // walk through target. find sequential matches.\n            // if all chars aren't found then exit\n\n            for (;;) {\n              var isMatch = searchLowerCode === targetLowerCodes[targetI];\n\n              if (isMatch) {\n                matchesSimple[matchesSimpleLen++] = targetI;\n                ++searchI;\n                if (searchI === searchLen) break;\n                searchLowerCode = searchLowerCodes[typoSimpleI === 0 ? searchI : typoSimpleI === searchI ? searchI + 1 : typoSimpleI === searchI - 1 ? searchI - 1 : searchI];\n              }\n\n              ++targetI;\n\n              if (targetI >= targetLen) {\n                // Failed to find searchI\n                // Check for typo or exit\n                // we go as far as possible before trying to transpose\n                // then we transpose backwards until we reach the beginning\n                for (;;) {\n                  if (searchI <= 1) return null; // not allowed to transpose first char\n\n                  if (typoSimpleI === 0) {\n                    // we haven't tried to transpose yet\n                    --searchI;\n                    var searchLowerCodeNew = searchLowerCodes[searchI];\n                    if (searchLowerCode === searchLowerCodeNew) continue; // doesn't make sense to transpose a repeat char\n\n                    typoSimpleI = searchI;\n                  } else {\n                    if (typoSimpleI === 1) return null; // reached the end of the line for transposing\n\n                    --typoSimpleI;\n                    searchI = typoSimpleI;\n                    searchLowerCode = searchLowerCodes[searchI + 1];\n                    var searchLowerCodeNew = searchLowerCodes[searchI];\n                    if (searchLowerCode === searchLowerCodeNew) continue; // doesn't make sense to transpose a repeat char\n                  }\n\n                  matchesSimpleLen = searchI;\n                  targetI = matchesSimple[matchesSimpleLen - 1] + 1;\n                  break;\n                }\n              }\n            }\n\n            var searchI = 0;\n            var typoStrictI = 0;\n            var successStrict = false;\n            var matchesStrictLen = 0;\n            var nextBeginningIndexes = prepared._nextBeginningIndexes;\n            if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);\n            var firstPossibleI = targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1]; // Our target string successfully matched all characters in sequence!\n            // Let's try a more advanced and strict test to improve the score\n            // only count it as a match if it's consecutive or a beginning character!\n\n            if (targetI !== targetLen) for (;;) {\n              if (targetI >= targetLen) {\n                // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n                if (searchI <= 0) {\n                  // We failed to push chars forward for a better match\n                  // transpose, starting from the beginning\n                  ++typoStrictI;\n                  if (typoStrictI > searchLen - 2) break;\n                  if (searchLowerCodes[typoStrictI] === searchLowerCodes[typoStrictI + 1]) continue; // doesn't make sense to transpose a repeat char\n\n                  targetI = firstPossibleI;\n                  continue;\n                }\n\n                --searchI;\n                var lastMatch = matchesStrict[--matchesStrictLen];\n                targetI = nextBeginningIndexes[lastMatch];\n              } else {\n                var isMatch = searchLowerCodes[typoStrictI === 0 ? searchI : typoStrictI === searchI ? searchI + 1 : typoStrictI === searchI - 1 ? searchI - 1 : searchI] === targetLowerCodes[targetI];\n\n                if (isMatch) {\n                  matchesStrict[matchesStrictLen++] = targetI;\n                  ++searchI;\n\n                  if (searchI === searchLen) {\n                    successStrict = true;\n                    break;\n                  }\n\n                  ++targetI;\n                } else {\n                  targetI = nextBeginningIndexes[targetI];\n                }\n              }\n            }\n            {\n              // tally up the score & keep track of matches for highlighting later\n              if (successStrict) {\n                var matchesBest = matchesStrict;\n                var matchesBestLen = matchesStrictLen;\n              } else {\n                var matchesBest = matchesSimple;\n                var matchesBestLen = matchesSimpleLen;\n              }\n\n              var score = 0;\n              var lastTargetI = -1;\n\n              for (var i = 0; i < searchLen; ++i) {\n                var targetI = matchesBest[i]; // score only goes down if they're not consecutive\n\n                if (lastTargetI !== targetI - 1) score -= targetI;\n                lastTargetI = targetI;\n              }\n\n              if (!successStrict) {\n                score *= 1000;\n                if (typoSimpleI !== 0) score += -20;\n                /*typoPenalty*/\n              } else {\n                if (typoStrictI !== 0) score += -20;\n                /*typoPenalty*/\n              }\n\n              score -= targetLen - searchLen;\n              prepared.score = score;\n              prepared.indexes = new Array(matchesBestLen);\n\n              for (var i = matchesBestLen - 1; i >= 0; --i) {\n                prepared.indexes[i] = matchesBest[i];\n              }\n\n              return prepared;\n            }\n          },\n          algorithmNoTypo: function algorithmNoTypo(searchLowerCodes, prepared, searchLowerCode) {\n            var targetLowerCodes = prepared._targetLowerCodes;\n            var searchLen = searchLowerCodes.length;\n            var targetLen = targetLowerCodes.length;\n            var searchI = 0; // where we at\n\n            var targetI = 0; // where you at\n\n            var matchesSimpleLen = 0; // very basic fuzzy match; to remove non-matching targets ASAP!\n            // walk through target. find sequential matches.\n            // if all chars aren't found then exit\n\n            for (;;) {\n              var isMatch = searchLowerCode === targetLowerCodes[targetI];\n\n              if (isMatch) {\n                matchesSimple[matchesSimpleLen++] = targetI;\n                ++searchI;\n                if (searchI === searchLen) break;\n                searchLowerCode = searchLowerCodes[searchI];\n              }\n\n              ++targetI;\n              if (targetI >= targetLen) return null; // Failed to find searchI\n            }\n\n            var searchI = 0;\n            var successStrict = false;\n            var matchesStrictLen = 0;\n            var nextBeginningIndexes = prepared._nextBeginningIndexes;\n            if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);\n            targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1]; // Our target string successfully matched all characters in sequence!\n            // Let's try a more advanced and strict test to improve the score\n            // only count it as a match if it's consecutive or a beginning character!\n\n            if (targetI !== targetLen) for (;;) {\n              if (targetI >= targetLen) {\n                // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n                if (searchI <= 0) break; // We failed to push chars forward for a better match\n\n                --searchI;\n                var lastMatch = matchesStrict[--matchesStrictLen];\n                targetI = nextBeginningIndexes[lastMatch];\n              } else {\n                var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI];\n\n                if (isMatch) {\n                  matchesStrict[matchesStrictLen++] = targetI;\n                  ++searchI;\n\n                  if (searchI === searchLen) {\n                    successStrict = true;\n                    break;\n                  }\n\n                  ++targetI;\n                } else {\n                  targetI = nextBeginningIndexes[targetI];\n                }\n              }\n            }\n            {\n              // tally up the score & keep track of matches for highlighting later\n              if (successStrict) {\n                var matchesBest = matchesStrict;\n                var matchesBestLen = matchesStrictLen;\n              } else {\n                var matchesBest = matchesSimple;\n                var matchesBestLen = matchesSimpleLen;\n              }\n\n              var score = 0;\n              var lastTargetI = -1;\n\n              for (var i = 0; i < searchLen; ++i) {\n                var targetI = matchesBest[i]; // score only goes down if they're not consecutive\n\n                if (lastTargetI !== targetI - 1) score -= targetI;\n                lastTargetI = targetI;\n              }\n\n              if (!successStrict) score *= 1000;\n              score -= targetLen - searchLen;\n              prepared.score = score;\n              prepared.indexes = new Array(matchesBestLen);\n\n              for (var i = matchesBestLen - 1; i >= 0; --i) {\n                prepared.indexes[i] = matchesBest[i];\n              }\n\n              return prepared;\n            }\n          },\n          prepareLowerCodes: function prepareLowerCodes(str) {\n            var strLen = str.length;\n            var lowerCodes = []; // new Array(strLen)    sparse array is too slow\n\n            var lower = str.toLowerCase();\n\n            for (var i = 0; i < strLen; ++i) {\n              lowerCodes[i] = lower.charCodeAt(i);\n            }\n\n            return lowerCodes;\n          },\n          prepareBeginningIndexes: function prepareBeginningIndexes(target) {\n            var targetLen = target.length;\n            var beginningIndexes = [];\n            var beginningIndexesLen = 0;\n            var wasUpper = false;\n            var wasAlphanum = false;\n\n            for (var i = 0; i < targetLen; ++i) {\n              var targetCode = target.charCodeAt(i);\n              var isUpper = targetCode >= 65 && targetCode <= 90;\n              var isAlphanum = isUpper || targetCode >= 97 && targetCode <= 122 || targetCode >= 48 && targetCode <= 57;\n              var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum;\n              wasUpper = isUpper;\n              wasAlphanum = isAlphanum;\n              if (isBeginning) beginningIndexes[beginningIndexesLen++] = i;\n            }\n\n            return beginningIndexes;\n          },\n          prepareNextBeginningIndexes: function prepareNextBeginningIndexes(target) {\n            var targetLen = target.length;\n            var beginningIndexes = fuzzysort.prepareBeginningIndexes(target);\n            var nextBeginningIndexes = []; // new Array(targetLen)     sparse array is too slow\n\n            var lastIsBeginning = beginningIndexes[0];\n            var lastIsBeginningI = 0;\n\n            for (var i = 0; i < targetLen; ++i) {\n              if (lastIsBeginning > i) {\n                nextBeginningIndexes[i] = lastIsBeginning;\n              } else {\n                lastIsBeginning = beginningIndexes[++lastIsBeginningI];\n                nextBeginningIndexes[i] = lastIsBeginning === undefined ? targetLen : lastIsBeginning;\n              }\n            }\n\n            return nextBeginningIndexes;\n          },\n          cleanup: cleanup,\n          new: fuzzysortNew\n        };\n        return fuzzysort;\n      } // fuzzysortNew\n      // This stuff is outside fuzzysortNew, because it's shared with instances of fuzzysort.new()\n\n\n      var isNode = typeof commonjsRequire !== 'undefined' && typeof window === 'undefined';\n      var MyMap = typeof Map === 'function' ? Map : function () {\n        var s = Object.create(null);\n\n        this.get = function (k) {\n          return s[k];\n        };\n\n        this.set = function (k, val) {\n          s[k] = val;\n          return this;\n        };\n\n        this.clear = function () {\n          s = Object.create(null);\n        };\n      };\n      var preparedCache = new MyMap();\n      var preparedSearchCache = new MyMap();\n      var noResults = [];\n      noResults.total = 0;\n      var matchesSimple = [];\n      var matchesStrict = [];\n\n      function cleanup() {\n        preparedCache.clear();\n        preparedSearchCache.clear();\n        matchesSimple = [];\n        matchesStrict = [];\n      }\n\n      function defaultScoreFn(a) {\n        var max = -9007199254740991;\n\n        for (var i = a.length - 1; i >= 0; --i) {\n          var result = a[i];\n          if (result === null) continue;\n          var score = result.score;\n          if (score > max) max = score;\n        }\n\n        if (max === -9007199254740991) return null;\n        return max;\n      } // prop = 'key'              2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\n      // prop = 'key1.key2'        10ms\n      // prop = ['key1', 'key2']   27ms\n\n\n      function getValue(obj, prop) {\n        var tmp = obj[prop];\n        if (tmp !== undefined) return tmp;\n        var segs = prop;\n        if (!Array.isArray(prop)) segs = prop.split('.');\n        var len = segs.length;\n        var i = -1;\n\n        while (obj && ++i < len) {\n          obj = obj[segs[i]];\n        }\n\n        return obj;\n      }\n\n      function isObj(x) {\n        return _typeof(x) === 'object';\n      } // faster as a function\n      // Hacked version of https://github.com/lemire/FastPriorityQueue.js\n\n\n      var fastpriorityqueue = function fastpriorityqueue() {\n        var r = [],\n            o = 0,\n            e = {};\n\n        function n() {\n          for (var e = 0, n = r[e], c = 1; c < o;) {\n            var f = c + 1;\n            e = c, f < o && r[f].score < r[c].score && (e = f), r[e - 1 >> 1] = r[e], c = 1 + (e << 1);\n          }\n\n          for (var a = e - 1 >> 1; e > 0 && n.score < r[a].score; a = (e = a) - 1 >> 1) {\n            r[e] = r[a];\n          }\n\n          r[e] = n;\n        }\n\n        return e.add = function (e) {\n          var n = o;\n          r[o++] = e;\n\n          for (var c = n - 1 >> 1; n > 0 && e.score < r[c].score; c = (n = c) - 1 >> 1) {\n            r[n] = r[c];\n          }\n\n          r[n] = e;\n        }, e.poll = function () {\n          if (0 !== o) {\n            var e = r[0];\n            return r[0] = r[--o], n(), e;\n          }\n        }, e.peek = function (e) {\n          if (0 !== o) return r[0];\n        }, e.replaceTop = function (o) {\n          r[0] = o, n();\n        }, e;\n      };\n\n      var q = fastpriorityqueue(); // reuse this, except for async, it needs to make its own\n\n      return fuzzysortNew();\n    }); // UMD\n    // TODO: (performance) wasm version!?\n    // TODO: (performance) threads?\n    // TODO: (performance) avoid cache misses\n    // TODO: (performance) preparedCache is a memory leak\n    // TODO: (like sublime) backslash === forwardslash\n    // TODO: (like sublime) spaces: \"a b\" should do 2 searches 1 for a and 1 for b\n    // TODO: (scoring) garbage in targets that allows most searches to strict match need a penality\n    // TODO: (performance) idk if allowTypo is optimized\n\n  })(fuzzysort$1);\n\n  var fuzzysort = fuzzysort$1.exports;\n\n  var stats = {\n    failedTests: [],\n    defined: 0,\n    completed: 0\n  }; // Escape text for attribute or text content.\n\n  function escapeText(str) {\n    if (!str) {\n      return '';\n    } // Both single quotes and double quotes (for attributes)\n\n\n    return ('' + str).replace(/['\"<>&]/g, function (s) {\n      switch (s) {\n        case \"'\":\n          return '&#039;';\n\n        case '\"':\n          return '&quot;';\n\n        case '<':\n          return '&lt;';\n\n        case '>':\n          return '&gt;';\n\n        case '&':\n          return '&amp;';\n      }\n    });\n  }\n\n  (function () {\n    // Don't load the HTML Reporter on non-browser environments\n    if (!window$1 || !document) {\n      return;\n    }\n\n    var config = QUnit.config;\n    var hiddenTests = [];\n    var collapseNext = false;\n    var hasOwn = Object.prototype.hasOwnProperty;\n    var unfilteredUrl = setUrl({\n      filter: undefined,\n      module: undefined,\n      moduleId: undefined,\n      testId: undefined\n    });\n    var dropdownData = null;\n\n    function trim(string) {\n      if (typeof string.trim === 'function') {\n        return string.trim();\n      } else {\n        return string.replace(/^\\s+|\\s+$/g, '');\n      }\n    }\n\n    function addEvent(elem, type, fn) {\n      elem.addEventListener(type, fn, false);\n    }\n\n    function removeEvent(elem, type, fn) {\n      elem.removeEventListener(type, fn, false);\n    }\n\n    function addEvents(elems, type, fn) {\n      var i = elems.length;\n\n      while (i--) {\n        addEvent(elems[i], type, fn);\n      }\n    }\n\n    function hasClass(elem, name) {\n      return (' ' + elem.className + ' ').indexOf(' ' + name + ' ') >= 0;\n    }\n\n    function addClass(elem, name) {\n      if (!hasClass(elem, name)) {\n        elem.className += (elem.className ? ' ' : '') + name;\n      }\n    }\n\n    function toggleClass(elem, name, force) {\n      if (force || typeof force === 'undefined' && !hasClass(elem, name)) {\n        addClass(elem, name);\n      } else {\n        removeClass(elem, name);\n      }\n    }\n\n    function removeClass(elem, name) {\n      var set = ' ' + elem.className + ' '; // Class name may appear multiple times\n\n      while (set.indexOf(' ' + name + ' ') >= 0) {\n        set = set.replace(' ' + name + ' ', ' ');\n      } // Trim for prettiness\n\n\n      elem.className = trim(set);\n    }\n\n    function id(name) {\n      return document.getElementById && document.getElementById(name);\n    }\n\n    function abortTests() {\n      var abortButton = id('qunit-abort-tests-button');\n\n      if (abortButton) {\n        abortButton.disabled = true;\n        abortButton.innerHTML = 'Aborting...';\n      }\n\n      QUnit.config.queue.length = 0;\n      return false;\n    }\n\n    function interceptNavigation(ev) {\n      // Trim potential accidental whitespace so that QUnit doesn't throw an error about no tests matching the filter.\n      var filterInputElem = id('qunit-filter-input');\n      filterInputElem.value = trim(filterInputElem.value);\n      applyUrlParams();\n\n      if (ev && ev.preventDefault) {\n        ev.preventDefault();\n      }\n\n      return false;\n    }\n\n    function getUrlConfigHtml() {\n      var selection = false;\n      var urlConfig = config.urlConfig;\n      var urlConfigHtml = '';\n\n      for (var i = 0; i < urlConfig.length; i++) {\n        // Options can be either strings or objects with nonempty \"id\" properties\n        var val = config.urlConfig[i];\n\n        if (typeof val === 'string') {\n          val = {\n            id: val,\n            label: val\n          };\n        }\n\n        var escaped = escapeText(val.id);\n        var escapedTooltip = escapeText(val.tooltip);\n\n        if (!val.value || typeof val.value === 'string') {\n          urlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped + \"' title='\" + escapedTooltip + \"'><input id='qunit-urlconfig-\" + escaped + \"' name='\" + escaped + \"' type='checkbox'\" + (val.value ? \" value='\" + escapeText(val.value) + \"'\" : '') + (config[val.id] ? \" checked='checked'\" : '') + \" title='\" + escapedTooltip + \"' />\" + escapeText(val.label) + '</label>';\n        } else {\n          urlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped + \"' title='\" + escapedTooltip + \"'>\" + val.label + \": </label><select id='qunit-urlconfig-\" + escaped + \"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\n\n          if (Array.isArray(val.value)) {\n            for (var j = 0; j < val.value.length; j++) {\n              escaped = escapeText(val.value[j]);\n              urlConfigHtml += \"<option value='\" + escaped + \"'\" + (config[val.id] === val.value[j] ? (selection = true) && \" selected='selected'\" : '') + '>' + escaped + '</option>';\n            }\n          } else {\n            for (var _j in val.value) {\n              if (hasOwn.call(val.value, _j)) {\n                urlConfigHtml += \"<option value='\" + escapeText(_j) + \"'\" + (config[val.id] === _j ? (selection = true) && \" selected='selected'\" : '') + '>' + escapeText(val.value[_j]) + '</option>';\n              }\n            }\n          }\n\n          if (config[val.id] && !selection) {\n            escaped = escapeText(config[val.id]);\n            urlConfigHtml += \"<option value='\" + escaped + \"' selected='selected' disabled='disabled'>\" + escaped + '</option>';\n          }\n\n          urlConfigHtml += '</select>';\n        }\n      }\n\n      return urlConfigHtml;\n    } // Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\n    // Updates the URL with the new state of `config.urlConfig` values.\n\n\n    function toolbarChanged() {\n      var field = this;\n      var params = {}; // Detect if field is a select menu or a checkbox\n\n      var value;\n\n      if ('selectedIndex' in field) {\n        value = field.options[field.selectedIndex].value || undefined;\n      } else {\n        value = field.checked ? field.defaultValue || true : undefined;\n      }\n\n      params[field.name] = value;\n      var updatedUrl = setUrl(params); // Check if we can apply the change without a page refresh\n\n      if (field.name === 'hidepassed' && 'replaceState' in window$1.history) {\n        QUnit.urlParams[field.name] = value;\n        config[field.name] = value || false;\n        var tests = id('qunit-tests');\n\n        if (tests) {\n          var length = tests.children.length;\n          var children = tests.children;\n\n          if (field.checked) {\n            for (var i = 0; i < length; i++) {\n              var test = children[i];\n              var className = test ? test.className : '';\n              var classNameHasPass = className.indexOf('pass') > -1;\n              var classNameHasSkipped = className.indexOf('skipped') > -1;\n\n              if (classNameHasPass || classNameHasSkipped) {\n                hiddenTests.push(test);\n              }\n            }\n\n            var _iterator = _createForOfIteratorHelper(hiddenTests),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var hiddenTest = _step.value;\n                tests.removeChild(hiddenTest);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          } else {\n            var _test;\n\n            while ((_test = hiddenTests.pop()) != null) {\n              tests.appendChild(_test);\n            }\n          }\n        }\n\n        window$1.history.replaceState(null, '', updatedUrl);\n      } else {\n        window$1.location = updatedUrl;\n      }\n    }\n\n    function setUrl(params) {\n      var querystring = '?';\n      var location = window$1.location;\n      params = extend(extend({}, QUnit.urlParams), params);\n\n      for (var key in params) {\n        // Skip inherited or undefined properties\n        if (hasOwn.call(params, key) && params[key] !== undefined) {\n          // Output a parameter for each value of this key\n          // (but usually just one)\n          var arrValue = [].concat(params[key]);\n\n          for (var i = 0; i < arrValue.length; i++) {\n            querystring += encodeURIComponent(key);\n\n            if (arrValue[i] !== true) {\n              querystring += '=' + encodeURIComponent(arrValue[i]);\n            }\n\n            querystring += '&';\n          }\n        }\n      }\n\n      return location.protocol + '//' + location.host + location.pathname + querystring.slice(0, -1);\n    }\n\n    function applyUrlParams() {\n      var filter = id('qunit-filter-input').value;\n      window$1.location = setUrl({\n        filter: filter === '' ? undefined : filter,\n        moduleId: _toConsumableArray(dropdownData.selectedMap.keys()),\n        // Remove module and testId filter\n        module: undefined,\n        testId: undefined\n      });\n    }\n\n    function toolbarUrlConfigContainer() {\n      var urlConfigContainer = document.createElement('span');\n      urlConfigContainer.innerHTML = getUrlConfigHtml();\n      addClass(urlConfigContainer, 'qunit-url-config');\n      addEvents(urlConfigContainer.getElementsByTagName('input'), 'change', toolbarChanged);\n      addEvents(urlConfigContainer.getElementsByTagName('select'), 'change', toolbarChanged);\n      return urlConfigContainer;\n    }\n\n    function abortTestsButton() {\n      var button = document.createElement('button');\n      button.id = 'qunit-abort-tests-button';\n      button.innerHTML = 'Abort';\n      addEvent(button, 'click', abortTests);\n      return button;\n    }\n\n    function toolbarLooseFilter() {\n      var filter = document.createElement('form');\n      var label = document.createElement('label');\n      var input = document.createElement('input');\n      var button = document.createElement('button');\n      addClass(filter, 'qunit-filter');\n      label.innerHTML = 'Filter: ';\n      input.type = 'text';\n      input.value = config.filter || '';\n      input.name = 'filter';\n      input.id = 'qunit-filter-input';\n      button.innerHTML = 'Go';\n      label.appendChild(input);\n      filter.appendChild(label);\n      filter.appendChild(document.createTextNode(' '));\n      filter.appendChild(button);\n      addEvent(filter, 'submit', interceptNavigation);\n      return filter;\n    }\n\n    function createModuleListItem(moduleId, name, checked) {\n      return '<li><label class=\"clickable' + (checked ? ' checked' : '') + '\"><input type=\"checkbox\" ' + 'value=\"' + escapeText(moduleId) + '\"' + (checked ? ' checked=\"checked\"' : '') + ' />' + escapeText(name) + '</label></li>';\n    }\n    /**\n     * @param {Array} Results from fuzzysort\n     * @return {string} HTML\n     */\n\n\n    function moduleListHtml(results) {\n      var html = ''; // Hoist the already selected items, and show them always\n      // even if not matched by the current search.\n\n      dropdownData.selectedMap.forEach(function (name, moduleId) {\n        html += createModuleListItem(moduleId, name, true);\n      });\n\n      for (var i = 0; i < results.length; i++) {\n        var mod = results[i].obj;\n\n        if (!dropdownData.selectedMap.has(mod.moduleId)) {\n          html += createModuleListItem(mod.moduleId, mod.name, false);\n        }\n      }\n\n      return html;\n    }\n\n    function toolbarModuleFilter(beginDetails) {\n      var initialSelected = null;\n      dropdownData = {\n        options: beginDetails.modules.slice(),\n        selectedMap: new StringMap(),\n        isDirty: function isDirty() {\n          return _toConsumableArray(dropdownData.selectedMap.keys()).sort().join(',') !== _toConsumableArray(initialSelected.keys()).sort().join(',');\n        }\n      };\n\n      if (config.moduleId.length) {\n        // The module dropdown is seeded with the runtime configuration of the last run.\n        //\n        // We don't reference `config.moduleId` directly after this and keep our own\n        // copy because:\n        // 1. This naturaly filters out unknown moduleIds.\n        // 2. Gives us a place to manage and remember unsubmitted checkbox changes.\n        // 3. Gives us an efficient way to map a selected moduleId to module name\n        //    during rendering.\n        for (var i = 0; i < beginDetails.modules.length; i++) {\n          var mod = beginDetails.modules[i];\n\n          if (config.moduleId.indexOf(mod.moduleId) !== -1) {\n            dropdownData.selectedMap.set(mod.moduleId, mod.name);\n          }\n        }\n      }\n\n      initialSelected = new StringMap(dropdownData.selectedMap);\n      var moduleSearch = document.createElement('input');\n      moduleSearch.id = 'qunit-modulefilter-search';\n      moduleSearch.autocomplete = 'off';\n      addEvent(moduleSearch, 'input', searchInput);\n      addEvent(moduleSearch, 'input', searchFocus);\n      addEvent(moduleSearch, 'focus', searchFocus);\n      addEvent(moduleSearch, 'click', searchFocus);\n      var label = document.createElement('label');\n      label.htmlFor = 'qunit-modulefilter-search';\n      label.textContent = 'Module:';\n      var searchContainer = document.createElement('span');\n      searchContainer.id = 'qunit-modulefilter-search-container';\n      searchContainer.appendChild(moduleSearch);\n      var applyButton = document.createElement('button');\n      applyButton.textContent = 'Apply';\n      applyButton.title = 'Re-run the selected test modules';\n      addEvent(applyButton, 'click', applyUrlParams);\n      var resetButton = document.createElement('button');\n      resetButton.textContent = 'Reset';\n      resetButton.type = 'reset';\n      resetButton.title = 'Restore the previous module selection';\n      var clearButton = document.createElement('button');\n      clearButton.textContent = 'Select none';\n      clearButton.type = 'button';\n      clearButton.title = 'Clear the current module selection';\n      addEvent(clearButton, 'click', function () {\n        dropdownData.selectedMap.clear();\n        selectionChange();\n        searchInput();\n      });\n      var actions = document.createElement('span');\n      actions.id = 'qunit-modulefilter-actions';\n      actions.appendChild(applyButton);\n      actions.appendChild(resetButton);\n\n      if (initialSelected.size) {\n        // Only show clear button if functionally different from reset\n        actions.appendChild(clearButton);\n      }\n\n      var dropDownList = document.createElement('ul');\n      dropDownList.id = 'qunit-modulefilter-dropdown-list';\n      var dropDown = document.createElement('div');\n      dropDown.id = 'qunit-modulefilter-dropdown';\n      dropDown.style.display = 'none';\n      dropDown.appendChild(actions);\n      dropDown.appendChild(dropDownList);\n      addEvent(dropDown, 'change', selectionChange);\n      searchContainer.appendChild(dropDown); // Set initial moduleSearch.placeholder and clearButton/resetButton.\n\n      selectionChange();\n      var moduleFilter = document.createElement('form');\n      moduleFilter.id = 'qunit-modulefilter';\n      moduleFilter.appendChild(label);\n      moduleFilter.appendChild(document.createTextNode(' '));\n      moduleFilter.appendChild(searchContainer);\n      addEvent(moduleFilter, 'submit', interceptNavigation);\n      addEvent(moduleFilter, 'reset', function () {\n        dropdownData.selectedMap = new StringMap(initialSelected); // Set moduleSearch.placeholder and reflect non-dirty state\n\n        selectionChange();\n        searchInput();\n      }); // Enables show/hide for the dropdown\n\n      function searchFocus() {\n        if (dropDown.style.display !== 'none') {\n          return;\n        } // Optimization: Defer rendering options until focussed.\n        // https://github.com/qunitjs/qunit/issues/1664\n\n\n        searchInput();\n        dropDown.style.display = 'block'; // Hide on Escape keydown or on click outside the container\n\n        addEvent(document, 'click', hideHandler);\n        addEvent(document, 'keydown', hideHandler);\n\n        function hideHandler(e) {\n          var inContainer = moduleFilter.contains(e.target);\n\n          if (e.keyCode === 27 || !inContainer) {\n            if (e.keyCode === 27 && inContainer) {\n              moduleSearch.focus();\n            }\n\n            dropDown.style.display = 'none';\n            removeEvent(document, 'click', hideHandler);\n            removeEvent(document, 'keydown', hideHandler);\n            moduleSearch.value = '';\n            searchInput();\n          }\n        }\n      }\n      /**\n       * @param {string} searchText\n       * @return {string} HTML\n       */\n\n\n      function filterModules(searchText) {\n        var results;\n\n        if (searchText === '') {\n          // Improve on-boarding experience by having an immediate display of\n          // module names, indicating how the interface works. This also makes\n          // for a quicker interaction in the common case of small projects.\n          // Don't mandate typing just to get the menu.\n          results = dropdownData.options.slice(0, 20).map(function (obj) {\n            // Fake empty results. https://github.com/farzher/fuzzysort/issues/41\n            return {\n              obj: obj\n            };\n          });\n        } else {\n          results = fuzzysort.go(searchText, dropdownData.options, {\n            limit: 20,\n            key: 'name',\n            allowTypo: true\n          });\n        }\n\n        return moduleListHtml(results);\n      } // Processes module search box input\n\n\n      var searchInputTimeout;\n\n      function searchInput() {\n        // Use a debounce with a ~0ms timeout. This is effectively instantaneous,\n        // but is better than undebounced because it avoids an ever-growing\n        // backlog of unprocessed now-outdated input events if fuzzysearch or\n        // drodown DOM is slow (e.g. very large test suite).\n        window$1.clearTimeout(searchInputTimeout);\n        searchInputTimeout = window$1.setTimeout(function () {\n          dropDownList.innerHTML = filterModules(moduleSearch.value);\n        });\n      } // Processes checkbox change, or a generic render (initial render, or after reset event)\n      // Avoid any dropdown rendering here as this is used by toolbarModuleFilter()\n      // during the initial render, which should not delay test execution.\n\n\n      function selectionChange(evt) {\n        var checkbox = evt && evt.target || null;\n\n        if (checkbox) {\n          // Update internal state\n          if (checkbox.checked) {\n            dropdownData.selectedMap.set(checkbox.value, checkbox.parentNode.textContent);\n          } else {\n            dropdownData.selectedMap.delete(checkbox.value);\n          } // Update UI state\n\n\n          toggleClass(checkbox.parentNode, 'checked', checkbox.checked);\n        }\n\n        var textForm = dropdownData.selectedMap.size ? dropdownData.selectedMap.size + ' ' + (dropdownData.selectedMap.size === 1 ? 'module' : 'modules') : 'All modules';\n        moduleSearch.placeholder = textForm;\n        moduleSearch.title = 'Type to search through and reduce the list.';\n        resetButton.disabled = !dropdownData.isDirty();\n        clearButton.style.display = dropdownData.selectedMap.size ? '' : 'none';\n      }\n\n      return moduleFilter;\n    }\n\n    function appendToolbar(beginDetails) {\n      var toolbar = id('qunit-testrunner-toolbar');\n\n      if (toolbar) {\n        toolbar.appendChild(toolbarUrlConfigContainer());\n        var toolbarFilters = document.createElement('span');\n        toolbarFilters.id = 'qunit-toolbar-filters';\n        toolbarFilters.appendChild(toolbarLooseFilter());\n        toolbarFilters.appendChild(toolbarModuleFilter(beginDetails));\n        var clearfix = document.createElement('div');\n        clearfix.className = 'clearfix';\n        toolbar.appendChild(toolbarFilters);\n        toolbar.appendChild(clearfix);\n      }\n    }\n\n    function appendHeader() {\n      var header = id('qunit-header');\n\n      if (header) {\n        header.innerHTML = \"<a href='\" + escapeText(unfilteredUrl) + \"'>\" + header.innerHTML + '</a> ';\n      }\n    }\n\n    function appendBanner() {\n      var banner = id('qunit-banner');\n\n      if (banner) {\n        banner.className = '';\n      }\n    }\n\n    function appendTestResults() {\n      var tests = id('qunit-tests');\n      var result = id('qunit-testresult');\n      var controls;\n\n      if (result) {\n        result.parentNode.removeChild(result);\n      }\n\n      if (tests) {\n        tests.innerHTML = '';\n        result = document.createElement('p');\n        result.id = 'qunit-testresult';\n        result.className = 'result';\n        tests.parentNode.insertBefore(result, tests);\n        result.innerHTML = '<div id=\"qunit-testresult-display\">Running...<br />&#160;</div>' + '<div id=\"qunit-testresult-controls\"></div>' + '<div class=\"clearfix\"></div>';\n        controls = id('qunit-testresult-controls');\n      }\n\n      if (controls) {\n        controls.appendChild(abortTestsButton());\n      }\n    }\n\n    function appendFilteredTest() {\n      var testId = QUnit.config.testId;\n\n      if (!testId || testId.length <= 0) {\n        return '';\n      }\n\n      return \"<div id='qunit-filteredTest'>Rerunning selected tests: \" + escapeText(testId.join(', ')) + \" <a id='qunit-clearFilter' href='\" + escapeText(unfilteredUrl) + \"'>Run all tests</a></div>\";\n    }\n\n    function appendUserAgent() {\n      var userAgent = id('qunit-userAgent');\n\n      if (userAgent) {\n        userAgent.innerHTML = '';\n        userAgent.appendChild(document.createTextNode('QUnit ' + QUnit.version + '; ' + navigator.userAgent));\n      }\n    }\n\n    function appendInterface(beginDetails) {\n      var qunit = id('qunit'); // For compat with QUnit 1.2, and to support fully custom theme HTML,\n      // we will use any existing elements if no id=\"qunit\" element exists.\n      //\n      // Note that we don't fail or fallback to creating it ourselves,\n      // because not having id=\"qunit\" (and not having the below elements)\n      // simply means QUnit acts headless, allowing users to use their own\n      // reporters, or for a test runner to listen for events directly without\n      // having the HTML reporter actively render anything.\n\n      if (qunit) {\n        qunit.setAttribute('role', 'main'); // Since QUnit 1.3, these are created automatically if the page\n        // contains id=\"qunit\".\n\n        qunit.innerHTML = \"<h1 id='qunit-header'>\" + escapeText(document.title) + '</h1>' + \"<h2 id='qunit-banner'></h2>\" + \"<div id='qunit-testrunner-toolbar' role='navigation'></div>\" + appendFilteredTest() + \"<h2 id='qunit-userAgent'></h2>\" + \"<ol id='qunit-tests'></ol>\";\n      }\n\n      appendHeader();\n      appendBanner();\n      appendTestResults();\n      appendUserAgent();\n      appendToolbar(beginDetails);\n    }\n\n    function appendTest(name, testId, moduleName) {\n      var tests = id('qunit-tests');\n\n      if (!tests) {\n        return;\n      }\n\n      var title = document.createElement('strong');\n      title.innerHTML = getNameHtml(name, moduleName);\n      var testBlock = document.createElement('li');\n      testBlock.appendChild(title); // No ID or rerun link for \"global failure\" blocks\n\n      if (testId !== undefined) {\n        var rerunTrigger = document.createElement('a');\n        rerunTrigger.innerHTML = 'Rerun';\n        rerunTrigger.href = setUrl({\n          testId: testId\n        });\n        testBlock.id = 'qunit-test-output-' + testId;\n        testBlock.appendChild(rerunTrigger);\n      }\n\n      var assertList = document.createElement('ol');\n      assertList.className = 'qunit-assert-list';\n      testBlock.appendChild(assertList);\n      tests.appendChild(testBlock);\n      return testBlock;\n    } // HTML Reporter initialization and load\n\n\n    QUnit.on('runStart', function (runStart) {\n      stats.defined = runStart.testCounts.total;\n    });\n    QUnit.begin(function (beginDetails) {\n      // Initialize QUnit elements\n      // This is done from begin() instead of runStart, because\n      // urlparams.js uses begin(), which we need to wait for.\n      // urlparams.js in turn uses begin() to allow plugins to\n      // add entries to QUnit.config.urlConfig, which may be done\n      // asynchronously.\n      // <https://github.com/qunitjs/qunit/issues/1657>\n      appendInterface(beginDetails);\n    });\n\n    function getRerunFailedHtml(failedTests) {\n      if (failedTests.length === 0) {\n        return '';\n      }\n\n      var href = setUrl({\n        testId: failedTests\n      });\n      return [\"<br /><a href='\" + escapeText(href) + \"'>\", failedTests.length === 1 ? 'Rerun 1 failed test' : 'Rerun ' + failedTests.length + ' failed tests', '</a>'].join('');\n    }\n\n    QUnit.on('runEnd', function (runEnd) {\n      var banner = id('qunit-banner');\n      var tests = id('qunit-tests');\n      var abortButton = id('qunit-abort-tests-button');\n      var assertPassed = config.stats.all - config.stats.bad;\n      var html = [runEnd.testCounts.total, ' tests completed in ', runEnd.runtime, ' milliseconds, with ', runEnd.testCounts.failed, ' failed, ', runEnd.testCounts.skipped, ' skipped, and ', runEnd.testCounts.todo, ' todo.<br />', \"<span class='passed'>\", assertPassed, \"</span> assertions of <span class='total'>\", config.stats.all, \"</span> passed, <span class='failed'>\", config.stats.bad, '</span> failed.', getRerunFailedHtml(stats.failedTests)].join('');\n      var test;\n      var assertLi;\n      var assertList; // Update remaining tests to aborted\n\n      if (abortButton && abortButton.disabled) {\n        html = 'Tests aborted after ' + runEnd.runtime + ' milliseconds.';\n\n        for (var i = 0; i < tests.children.length; i++) {\n          test = tests.children[i];\n\n          if (test.className === '' || test.className === 'running') {\n            test.className = 'aborted';\n            assertList = test.getElementsByTagName('ol')[0];\n            assertLi = document.createElement('li');\n            assertLi.className = 'fail';\n            assertLi.innerHTML = 'Test aborted.';\n            assertList.appendChild(assertLi);\n          }\n        }\n      }\n\n      if (banner && (!abortButton || abortButton.disabled === false)) {\n        banner.className = runEnd.status === 'failed' ? 'qunit-fail' : 'qunit-pass';\n      }\n\n      if (abortButton) {\n        abortButton.parentNode.removeChild(abortButton);\n      }\n\n      if (tests) {\n        id('qunit-testresult-display').innerHTML = html;\n      }\n\n      if (config.altertitle && document.title) {\n        // Show ✖ for good, ✔ for bad suite result in title\n        // use escape sequences in case file gets loaded with non-utf-8\n        // charset\n        document.title = [runEnd.status === 'failed' ? \"\\u2716\" : \"\\u2714\", document.title.replace(/^[\\u2714\\u2716] /i, '')].join(' ');\n      } // Scroll back to top to show results\n\n\n      if (config.scrolltop && window$1.scrollTo) {\n        window$1.scrollTo(0, 0);\n      }\n    });\n\n    function getNameHtml(name, module) {\n      var nameHtml = '';\n\n      if (module) {\n        nameHtml = \"<span class='module-name'>\" + escapeText(module) + '</span>: ';\n      }\n\n      nameHtml += \"<span class='test-name'>\" + escapeText(name) + '</span>';\n      return nameHtml;\n    }\n\n    function getProgressHtml(stats) {\n      return [stats.completed, ' / ', stats.defined, ' tests completed.<br />'].join('');\n    }\n\n    QUnit.testStart(function (details) {\n      var running, bad;\n      appendTest(details.name, details.testId, details.module);\n      running = id('qunit-testresult-display');\n\n      if (running) {\n        addClass(running, 'running');\n        bad = QUnit.config.reorder && details.previousFailure;\n        running.innerHTML = [getProgressHtml(stats), bad ? 'Rerunning previously failed test: <br />' : 'Running: ', getNameHtml(details.name, details.module), getRerunFailedHtml(stats.failedTests)].join('');\n      }\n    });\n\n    function stripHtml(string) {\n      // Strip tags, html entity and whitespaces\n      return string.replace(/<\\/?[^>]+(>|$)/g, '').replace(/&quot;/g, '').replace(/\\s+/g, '');\n    }\n\n    QUnit.log(function (details) {\n      var testItem = id('qunit-test-output-' + details.testId);\n\n      if (!testItem) {\n        return;\n      }\n\n      var message = escapeText(details.message) || (details.result ? 'okay' : 'failed');\n      message = \"<span class='test-message'>\" + message + '</span>';\n      message += \"<span class='runtime'>@ \" + details.runtime + ' ms</span>';\n      var expected;\n      var actual;\n      var diff;\n      var showDiff = false; // The pushFailure doesn't provide details.expected\n      // when it calls, it's implicit to also not show expected and diff stuff\n      // Also, we need to check details.expected existence, as it can exist and be undefined\n\n      if (!details.result && hasOwn.call(details, 'expected')) {\n        if (details.negative) {\n          expected = 'NOT ' + QUnit.dump.parse(details.expected);\n        } else {\n          expected = QUnit.dump.parse(details.expected);\n        }\n\n        actual = QUnit.dump.parse(details.actual);\n        message += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" + escapeText(expected) + '</pre></td></tr>';\n\n        if (actual !== expected) {\n          message += \"<tr class='test-actual'><th>Result: </th><td><pre>\" + escapeText(actual) + '</pre></td></tr>';\n\n          if (typeof details.actual === 'number' && typeof details.expected === 'number') {\n            if (!isNaN(details.actual) && !isNaN(details.expected)) {\n              showDiff = true;\n              diff = details.actual - details.expected;\n              diff = (diff > 0 ? '+' : '') + diff;\n            }\n          } else if (typeof details.actual !== 'boolean' && typeof details.expected !== 'boolean') {\n            diff = QUnit.diff(expected, actual); // don't show diff if there is zero overlap\n\n            showDiff = stripHtml(diff).length !== stripHtml(expected).length + stripHtml(actual).length;\n          }\n\n          if (showDiff) {\n            message += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" + diff + '</pre></td></tr>';\n          }\n        } else if (expected.indexOf('[object Array]') !== -1 || expected.indexOf('[object Object]') !== -1) {\n          message += \"<tr class='test-message'><th>Message: </th><td>\" + 'Diff suppressed as the depth of object is more than current max depth (' + QUnit.config.maxDepth + ').<p>Hint: Use <code>QUnit.dump.maxDepth</code> to ' + \" run with a higher max depth or <a href='\" + escapeText(setUrl({\n            maxDepth: -1\n          })) + \"'>\" + 'Rerun</a> without max depth.</p></td></tr>';\n        } else {\n          message += \"<tr class='test-message'><th>Message: </th><td>\" + 'Diff suppressed as the expected and actual results have an equivalent' + ' serialization</td></tr>';\n        }\n\n        if (details.source) {\n          message += \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText(details.source) + '</pre></td></tr>';\n        }\n\n        message += '</table>'; // This occurs when pushFailure is set and we have an extracted stack trace\n      } else if (!details.result && details.source) {\n        message += '<table>' + \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText(details.source) + '</pre></td></tr>' + '</table>';\n      }\n\n      var assertList = testItem.getElementsByTagName('ol')[0];\n      var assertLi = document.createElement('li');\n      assertLi.className = details.result ? 'pass' : 'fail';\n      assertLi.innerHTML = message;\n      assertList.appendChild(assertLi);\n    });\n    QUnit.testDone(function (details) {\n      var tests = id('qunit-tests');\n      var testItem = id('qunit-test-output-' + details.testId);\n\n      if (!tests || !testItem) {\n        return;\n      }\n\n      removeClass(testItem, 'running');\n      var status;\n\n      if (details.failed > 0) {\n        status = 'failed';\n      } else if (details.todo) {\n        status = 'todo';\n      } else {\n        status = details.skipped ? 'skipped' : 'passed';\n      }\n\n      var assertList = testItem.getElementsByTagName('ol')[0];\n      var good = details.passed;\n      var bad = details.failed; // This test passed if it has no unexpected failed assertions\n\n      var testPassed = details.failed > 0 ? details.todo : !details.todo;\n\n      if (testPassed) {\n        // Collapse the passing tests\n        addClass(assertList, 'qunit-collapsed');\n      } else {\n        stats.failedTests.push(details.testId);\n\n        if (config.collapse) {\n          if (!collapseNext) {\n            // Skip collapsing the first failing test\n            collapseNext = true;\n          } else {\n            // Collapse remaining tests\n            addClass(assertList, 'qunit-collapsed');\n          }\n        }\n      } // The testItem.firstChild is the test name\n\n\n      var testTitle = testItem.firstChild;\n      var testCounts = bad ? \"<b class='failed'>\" + bad + '</b>, ' + \"<b class='passed'>\" + good + '</b>, ' : '';\n      testTitle.innerHTML += \" <b class='counts'>(\" + testCounts + details.assertions.length + ')</b>';\n      stats.completed++;\n\n      if (details.skipped) {\n        testItem.className = 'skipped';\n        var skipped = document.createElement('em');\n        skipped.className = 'qunit-skipped-label';\n        skipped.innerHTML = 'skipped';\n        testItem.insertBefore(skipped, testTitle);\n      } else {\n        addEvent(testTitle, 'click', function () {\n          toggleClass(assertList, 'qunit-collapsed');\n        });\n        testItem.className = testPassed ? 'pass' : 'fail';\n\n        if (details.todo) {\n          var todoLabel = document.createElement('em');\n          todoLabel.className = 'qunit-todo-label';\n          todoLabel.innerHTML = 'todo';\n          testItem.className += ' todo';\n          testItem.insertBefore(todoLabel, testTitle);\n        }\n\n        var time = document.createElement('span');\n        time.className = 'runtime';\n        time.innerHTML = details.runtime + ' ms';\n        testItem.insertBefore(time, assertList);\n      } // Show the source of the test when showing assertions\n\n\n      if (details.source) {\n        var sourceName = document.createElement('p');\n        sourceName.innerHTML = '<strong>Source: </strong>' + escapeText(details.source);\n        addClass(sourceName, 'qunit-source');\n\n        if (testPassed) {\n          addClass(sourceName, 'qunit-collapsed');\n        }\n\n        addEvent(testTitle, 'click', function () {\n          toggleClass(sourceName, 'qunit-collapsed');\n        });\n        testItem.appendChild(sourceName);\n      }\n\n      if (config.hidepassed && (status === 'passed' || details.skipped)) {\n        // use removeChild instead of remove because of support\n        hiddenTests.push(testItem);\n        tests.removeChild(testItem);\n      }\n    });\n    QUnit.on('error', function (error) {\n      var testItem = appendTest('global failure');\n\n      if (!testItem) {\n        // HTML Reporter is probably disabled or not yet initialized.\n        return;\n      } // Render similar to a failed assertion (see above QUnit.log callback)\n\n\n      var message = escapeText(errorString(error));\n      message = \"<span class='test-message'>\" + message + '</span>';\n\n      if (error && error.stack) {\n        message += '<table>' + \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText(error.stack) + '</pre></td></tr>' + '</table>';\n      }\n\n      var assertList = testItem.getElementsByTagName('ol')[0];\n      var assertLi = document.createElement('li');\n      assertLi.className = 'fail';\n      assertLi.innerHTML = message;\n      assertList.appendChild(assertLi); // Make it visible\n\n      testItem.className = 'fail';\n    }); // Avoid readyState issue with phantomjs\n    // Ref: #818\n\n    var usingPhantom = function (p) {\n      return p && p.version && p.version.major > 0;\n    }(window$1.phantom);\n\n    if (usingPhantom) {\n      console$1.warn('Support for PhantomJS is deprecated and will be removed in QUnit 3.0.');\n    }\n\n    if (!usingPhantom && document.readyState === 'complete') {\n      QUnit.load();\n    } else {\n      addEvent(window$1, 'load', QUnit.load);\n    } // Wrap window.onerror. We will call the original window.onerror to see if\n    // the existing handler fully handles the error; if not, we will call the\n    // QUnit.onError function.\n\n\n    var originalWindowOnError = window$1.onerror; // Cover uncaught exceptions\n    // Returning true will suppress the default browser handler,\n    // returning false will let it run.\n\n    window$1.onerror = function (message, fileName, lineNumber, columnNumber, errorObj) {\n      var ret = false;\n\n      if (originalWindowOnError) {\n        for (var _len = arguments.length, args = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n          args[_key - 5] = arguments[_key];\n        }\n\n        ret = originalWindowOnError.call.apply(originalWindowOnError, [this, message, fileName, lineNumber, columnNumber, errorObj].concat(args));\n      } // Treat return value as window.onerror itself does,\n      // Only do our handling if not suppressed.\n\n\n      if (ret !== true) {\n        // If there is a current test that sets the internal `ignoreGlobalErrors` field\n        // (such as during `assert.throws()`), then the error is ignored and native\n        // error reporting is suppressed as well. This is because in browsers, an error\n        // can sometimes end up in `window.onerror` instead of in the local try/catch.\n        // This ignoring of errors does not apply to our general onUncaughtException\n        // method, nor to our `unhandledRejection` handlers, as those are not meant\n        // to receive an \"expected\" error during `assert.throws()`.\n        if (config.current && config.current.ignoreGlobalErrors) {\n          return true;\n        } // According to\n        // https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror,\n        // most modern browsers support an errorObj argument; use that to\n        // get a full stack trace if it's available.\n\n\n        var error = errorObj || new Error(message);\n\n        if (!error.stack && fileName && lineNumber) {\n          error.stack = \"\".concat(fileName, \":\").concat(lineNumber);\n        }\n\n        QUnit.onUncaughtException(error);\n      }\n\n      return ret;\n    };\n\n    window$1.addEventListener('unhandledrejection', function (event) {\n      QUnit.onUncaughtException(event.reason);\n    });\n  })();\n\n  /*\n   * This file is a modified version of google-diff-match-patch's JavaScript implementation\n   * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n   * modifications are licensed as more fully set forth in LICENSE.txt.\n   *\n   * The original source of google-diff-match-patch is attributable and licensed as follows:\n   *\n   * Copyright 2006 Google Inc.\n   * https://code.google.com/p/google-diff-match-patch/\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   * https://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * More Info:\n   *  https://code.google.com/p/google-diff-match-patch/\n   *\n   * Usage: QUnit.diff(expected, actual)\n   *\n   */\n\n  QUnit.diff = function () {\n    function DiffMatchPatch() {} //  DIFF FUNCTIONS\n\n    /**\n     * The data structure representing a diff is an array of tuples:\n     * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n     * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n     */\n\n\n    var DIFF_DELETE = -1;\n    var DIFF_INSERT = 1;\n    var DIFF_EQUAL = 0;\n    var hasOwn = Object.prototype.hasOwnProperty;\n    /**\n     * Find the differences between two texts.  Simplifies the problem by stripping\n     * any common prefix or suffix off the texts before diffing.\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n     *     then don't run a line-level diff first to identify the changed areas.\n     *     Defaults to true, which does a faster, slightly less optimal diff.\n     * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n     */\n\n    DiffMatchPatch.prototype.DiffMain = function (text1, text2, optChecklines) {\n      var deadline, checklines, commonlength, commonprefix, commonsuffix, diffs; // The diff must be complete in up to 1 second.\n\n      deadline = new Date().getTime() + 1000; // Check for null inputs.\n\n      if (text1 === null || text2 === null) {\n        throw new Error('Null input. (DiffMain)');\n      } // Check for equality (speedup).\n\n\n      if (text1 === text2) {\n        if (text1) {\n          return [[DIFF_EQUAL, text1]];\n        }\n\n        return [];\n      }\n\n      if (typeof optChecklines === 'undefined') {\n        optChecklines = true;\n      }\n\n      checklines = optChecklines; // Trim off common prefix (speedup).\n\n      commonlength = this.diffCommonPrefix(text1, text2);\n      commonprefix = text1.substring(0, commonlength);\n      text1 = text1.substring(commonlength);\n      text2 = text2.substring(commonlength); // Trim off common suffix (speedup).\n\n      commonlength = this.diffCommonSuffix(text1, text2);\n      commonsuffix = text1.substring(text1.length - commonlength);\n      text1 = text1.substring(0, text1.length - commonlength);\n      text2 = text2.substring(0, text2.length - commonlength); // Compute the diff on the middle block.\n\n      diffs = this.diffCompute(text1, text2, checklines, deadline); // Restore the prefix and suffix.\n\n      if (commonprefix) {\n        diffs.unshift([DIFF_EQUAL, commonprefix]);\n      }\n\n      if (commonsuffix) {\n        diffs.push([DIFF_EQUAL, commonsuffix]);\n      }\n\n      this.diffCleanupMerge(diffs);\n      return diffs;\n    };\n    /**\n     * Reduce the number of edits by eliminating operationally trivial equalities.\n     * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n     */\n\n\n    DiffMatchPatch.prototype.diffCleanupEfficiency = function (diffs) {\n      var changes, equalities, equalitiesLength, lastequality, pointer, preIns, preDel, postIns, postDel;\n      changes = false;\n      equalities = []; // Stack of indices where equalities are found.\n\n      equalitiesLength = 0; // Keeping our own length var is faster in JS.\n\n      /** @type {?string} */\n\n      lastequality = null; // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\n      pointer = 0; // Index of current position.\n      // Is there an insertion operation before the last equality.\n\n      preIns = false; // Is there a deletion operation before the last equality.\n\n      preDel = false; // Is there an insertion operation after the last equality.\n\n      postIns = false; // Is there a deletion operation after the last equality.\n\n      postDel = false;\n\n      while (pointer < diffs.length) {\n        // Equality found.\n        if (diffs[pointer][0] === DIFF_EQUAL) {\n          if (diffs[pointer][1].length < 4 && (postIns || postDel)) {\n            // Candidate found.\n            equalities[equalitiesLength++] = pointer;\n            preIns = postIns;\n            preDel = postDel;\n            lastequality = diffs[pointer][1];\n          } else {\n            // Not a candidate, and can never become one.\n            equalitiesLength = 0;\n            lastequality = null;\n          }\n\n          postIns = postDel = false; // An insertion or deletion.\n        } else {\n          if (diffs[pointer][0] === DIFF_DELETE) {\n            postDel = true;\n          } else {\n            postIns = true;\n          }\n          /*\n           * Five types to be split:\n           * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n           * <ins>A</ins>X<ins>C</ins><del>D</del>\n           * <ins>A</ins><del>B</del>X<ins>C</ins>\n           * <ins>A</del>X<ins>C</ins><del>D</del>\n           * <ins>A</ins><del>B</del>X<del>C</del>\n           */\n\n\n          if (lastequality && (preIns && preDel && postIns && postDel || lastequality.length < 2 && preIns + preDel + postIns + postDel === 3)) {\n            // Duplicate record.\n            diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]); // Change second copy to insert.\n\n            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n            equalitiesLength--; // Throw away the equality we just deleted;\n\n            lastequality = null;\n\n            if (preIns && preDel) {\n              // No changes made which could affect previous entry, keep going.\n              postIns = postDel = true;\n              equalitiesLength = 0;\n            } else {\n              equalitiesLength--; // Throw away the previous equality.\n\n              pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n              postIns = postDel = false;\n            }\n\n            changes = true;\n          }\n        }\n\n        pointer++;\n      }\n\n      if (changes) {\n        this.diffCleanupMerge(diffs);\n      }\n    };\n    /**\n     * Convert a diff array into a pretty HTML report.\n     * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n     * @param {integer} string to be beautified.\n     * @return {string} HTML representation.\n     */\n\n\n    DiffMatchPatch.prototype.diffPrettyHtml = function (diffs) {\n      var html = [];\n\n      for (var x = 0; x < diffs.length; x++) {\n        var op = diffs[x][0]; // Operation (insert, delete, equal)\n\n        var data = diffs[x][1]; // Text of change.\n\n        switch (op) {\n          case DIFF_INSERT:\n            html[x] = '<ins>' + escapeText(data) + '</ins>';\n            break;\n\n          case DIFF_DELETE:\n            html[x] = '<del>' + escapeText(data) + '</del>';\n            break;\n\n          case DIFF_EQUAL:\n            html[x] = '<span>' + escapeText(data) + '</span>';\n            break;\n        }\n      }\n\n      return html.join('');\n    };\n    /**\n     * Determine the common prefix of two strings.\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @return {number} The number of characters common to the start of each\n     *     string.\n     */\n\n\n    DiffMatchPatch.prototype.diffCommonPrefix = function (text1, text2) {\n      var pointermid, pointermax, pointermin, pointerstart; // Quick check for common null cases.\n\n      if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\n        return 0;\n      } // Binary search.\n      // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\n\n      pointermin = 0;\n      pointermax = Math.min(text1.length, text2.length);\n      pointermid = pointermax;\n      pointerstart = 0;\n\n      while (pointermin < pointermid) {\n        if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {\n          pointermin = pointermid;\n          pointerstart = pointermin;\n        } else {\n          pointermax = pointermid;\n        }\n\n        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n      }\n\n      return pointermid;\n    };\n    /**\n     * Determine the common suffix of two strings.\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @return {number} The number of characters common to the end of each string.\n     */\n\n\n    DiffMatchPatch.prototype.diffCommonSuffix = function (text1, text2) {\n      var pointermid, pointermax, pointermin, pointerend; // Quick check for common null cases.\n\n      if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {\n        return 0;\n      } // Binary search.\n      // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\n\n      pointermin = 0;\n      pointermax = Math.min(text1.length, text2.length);\n      pointermid = pointermax;\n      pointerend = 0;\n\n      while (pointermin < pointermid) {\n        if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n          pointermin = pointermid;\n          pointerend = pointermin;\n        } else {\n          pointermax = pointermid;\n        }\n\n        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n      }\n\n      return pointermid;\n    };\n    /**\n     * Find the differences between two texts.  Assumes that the texts do not\n     * have any common prefix or suffix.\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {boolean} checklines Speedup flag.  If false, then don't run a\n     *     line-level diff first to identify the changed areas.\n     *     If true, then run a faster, slightly less optimal diff.\n     * @param {number} deadline Time when the diff should be complete by.\n     * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n     * @private\n     */\n\n\n    DiffMatchPatch.prototype.diffCompute = function (text1, text2, checklines, deadline) {\n      var diffs, longtext, shorttext, i, hm, text1A, text2A, text1B, text2B, midCommon, diffsA, diffsB;\n\n      if (!text1) {\n        // Just add some text (speedup).\n        return [[DIFF_INSERT, text2]];\n      }\n\n      if (!text2) {\n        // Just delete some text (speedup).\n        return [[DIFF_DELETE, text1]];\n      }\n\n      longtext = text1.length > text2.length ? text1 : text2;\n      shorttext = text1.length > text2.length ? text2 : text1;\n      i = longtext.indexOf(shorttext);\n\n      if (i !== -1) {\n        // Shorter text is inside the longer text (speedup).\n        diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]]; // Swap insertions for deletions if diff is reversed.\n\n        if (text1.length > text2.length) {\n          diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n        }\n\n        return diffs;\n      }\n\n      if (shorttext.length === 1) {\n        // Single character string.\n        // After the previous speedup, the character can't be an equality.\n        return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n      } // Check to see if the problem can be split in two.\n\n\n      hm = this.diffHalfMatch(text1, text2);\n\n      if (hm) {\n        // A half-match was found, sort out the return data.\n        text1A = hm[0];\n        text1B = hm[1];\n        text2A = hm[2];\n        text2B = hm[3];\n        midCommon = hm[4]; // Send both pairs off for separate processing.\n\n        diffsA = this.DiffMain(text1A, text2A, checklines, deadline);\n        diffsB = this.DiffMain(text1B, text2B, checklines, deadline); // Merge the results.\n\n        return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n      }\n\n      if (checklines && text1.length > 100 && text2.length > 100) {\n        return this.diffLineMode(text1, text2, deadline);\n      }\n\n      return this.diffBisect(text1, text2, deadline);\n    };\n    /**\n     * Do the two texts share a substring which is at least half the length of the\n     * longer text?\n     * This speedup can produce non-minimal diffs.\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @return {Array.<string>} Five element Array, containing the prefix of\n     *     text1, the suffix of text1, the prefix of text2, the suffix of\n     *     text2 and the common middle.  Or null if there was no match.\n     * @private\n     */\n\n\n    DiffMatchPatch.prototype.diffHalfMatch = function (text1, text2) {\n      var longtext, shorttext, dmp, text1A, text2B, text2A, text1B, midCommon, hm1, hm2, hm;\n      longtext = text1.length > text2.length ? text1 : text2;\n      shorttext = text1.length > text2.length ? text2 : text1;\n\n      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n        return null; // Pointless.\n      }\n\n      dmp = this; // 'this' becomes 'window' in a closure.\n\n      /**\n       * Does a substring of shorttext exist within longtext such that the substring\n       * is at least half the length of longtext?\n       * Closure, but does not reference any external variables.\n       * @param {string} longtext Longer string.\n       * @param {string} shorttext Shorter string.\n       * @param {number} i Start index of quarter length substring within longtext.\n       * @return {Array.<string>} Five element Array, containing the prefix of\n       *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n       *     of shorttext and the common middle.  Or null if there was no match.\n       * @private\n       */\n\n      function diffHalfMatchI(longtext, shorttext, i) {\n        var seed, j, bestCommon, prefixLength, suffixLength, bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB; // Start with a 1/4 length substring at position i as a seed.\n\n        seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n        j = -1;\n        bestCommon = '';\n\n        while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {\n          prefixLength = dmp.diffCommonPrefix(longtext.substring(i), shorttext.substring(j));\n          suffixLength = dmp.diffCommonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\n\n          if (bestCommon.length < suffixLength + prefixLength) {\n            bestCommon = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n            bestLongtextA = longtext.substring(0, i - suffixLength);\n            bestLongtextB = longtext.substring(i + prefixLength);\n            bestShorttextA = shorttext.substring(0, j - suffixLength);\n            bestShorttextB = shorttext.substring(j + prefixLength);\n          }\n        }\n\n        if (bestCommon.length * 2 >= longtext.length) {\n          return [bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB, bestCommon];\n        } else {\n          return null;\n        }\n      } // First check if the second quarter is the seed for a half-match.\n\n\n      hm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4)); // Check again based on the third quarter.\n\n      hm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));\n\n      if (!hm1 && !hm2) {\n        return null;\n      } else if (!hm2) {\n        hm = hm1;\n      } else if (!hm1) {\n        hm = hm2;\n      } else {\n        // Both matched.  Select the longest.\n        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n      } // A half-match was found, sort out the return data.\n\n\n      if (text1.length > text2.length) {\n        text1A = hm[0];\n        text1B = hm[1];\n        text2A = hm[2];\n        text2B = hm[3];\n      } else {\n        text2A = hm[0];\n        text2B = hm[1];\n        text1A = hm[2];\n        text1B = hm[3];\n      }\n\n      midCommon = hm[4];\n      return [text1A, text1B, text2A, text2B, midCommon];\n    };\n    /**\n     * Do a quick line-level diff on both strings, then rediff the parts for\n     * greater accuracy.\n     * This speedup can produce non-minimal diffs.\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {number} deadline Time when the diff should be complete by.\n     * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n     * @private\n     */\n\n\n    DiffMatchPatch.prototype.diffLineMode = function (text1, text2, deadline) {\n      var a, diffs, linearray, pointer, countInsert, countDelete, textInsert, textDelete, j; // Scan the text on a line-by-line basis first.\n\n      a = this.diffLinesToChars(text1, text2);\n      text1 = a.chars1;\n      text2 = a.chars2;\n      linearray = a.lineArray;\n      diffs = this.DiffMain(text1, text2, false, deadline); // Convert the diff back to original text.\n\n      this.diffCharsToLines(diffs, linearray); // Eliminate freak matches (e.g. blank lines)\n\n      this.diffCleanupSemantic(diffs); // Rediff any replacement blocks, this time character-by-character.\n      // Add a dummy entry at the end.\n\n      diffs.push([DIFF_EQUAL, '']);\n      pointer = 0;\n      countDelete = 0;\n      countInsert = 0;\n      textDelete = '';\n      textInsert = '';\n\n      while (pointer < diffs.length) {\n        switch (diffs[pointer][0]) {\n          case DIFF_INSERT:\n            countInsert++;\n            textInsert += diffs[pointer][1];\n            break;\n\n          case DIFF_DELETE:\n            countDelete++;\n            textDelete += diffs[pointer][1];\n            break;\n\n          case DIFF_EQUAL:\n            // Upon reaching an equality, check for prior redundancies.\n            if (countDelete >= 1 && countInsert >= 1) {\n              // Delete the offending records and add the merged ones.\n              diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);\n              pointer = pointer - countDelete - countInsert;\n              a = this.DiffMain(textDelete, textInsert, false, deadline);\n\n              for (j = a.length - 1; j >= 0; j--) {\n                diffs.splice(pointer, 0, a[j]);\n              }\n\n              pointer = pointer + a.length;\n            }\n\n            countInsert = 0;\n            countDelete = 0;\n            textDelete = '';\n            textInsert = '';\n            break;\n        }\n\n        pointer++;\n      }\n\n      diffs.pop(); // Remove the dummy entry at the end.\n\n      return diffs;\n    };\n    /**\n     * Find the 'middle snake' of a diff, split the problem in two\n     * and return the recursively constructed diff.\n     * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {number} deadline Time at which to bail if not yet complete.\n     * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n     * @private\n     */\n\n\n    DiffMatchPatch.prototype.diffBisect = function (text1, text2, deadline) {\n      var text1Length, text2Length, maxD, vOffset, vLength, v1, v2, x, delta, front, k1start, k1end, k2start, k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2; // Cache the text lengths to prevent multiple calls.\n\n      text1Length = text1.length;\n      text2Length = text2.length;\n      maxD = Math.ceil((text1Length + text2Length) / 2);\n      vOffset = maxD;\n      vLength = 2 * maxD;\n      v1 = new Array(vLength);\n      v2 = new Array(vLength); // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n      // integers and undefined.\n\n      for (x = 0; x < vLength; x++) {\n        v1[x] = -1;\n        v2[x] = -1;\n      }\n\n      v1[vOffset + 1] = 0;\n      v2[vOffset + 1] = 0;\n      delta = text1Length - text2Length; // If the total number of characters is odd, then the front path will collide\n      // with the reverse path.\n\n      front = delta % 2 !== 0; // Offsets for start and end of k loop.\n      // Prevents mapping of space beyond the grid.\n\n      k1start = 0;\n      k1end = 0;\n      k2start = 0;\n      k2end = 0;\n\n      for (d = 0; d < maxD; d++) {\n        // Bail out if deadline is reached.\n        if (new Date().getTime() > deadline) {\n          break;\n        } // Walk the front path one step.\n\n\n        for (k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n          k1Offset = vOffset + k1;\n\n          if (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) {\n            x1 = v1[k1Offset + 1];\n          } else {\n            x1 = v1[k1Offset - 1] + 1;\n          }\n\n          y1 = x1 - k1;\n\n          while (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {\n            x1++;\n            y1++;\n          }\n\n          v1[k1Offset] = x1;\n\n          if (x1 > text1Length) {\n            // Ran off the right of the graph.\n            k1end += 2;\n          } else if (y1 > text2Length) {\n            // Ran off the bottom of the graph.\n            k1start += 2;\n          } else if (front) {\n            k2Offset = vOffset + delta - k1;\n\n            if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n              // Mirror x2 onto top-left coordinate system.\n              x2 = text1Length - v2[k2Offset];\n\n              if (x1 >= x2) {\n                // Overlap detected.\n                return this.diffBisectSplit(text1, text2, x1, y1, deadline);\n              }\n            }\n          }\n        } // Walk the reverse path one step.\n\n\n        for (k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n          k2Offset = vOffset + k2;\n\n          if (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) {\n            x2 = v2[k2Offset + 1];\n          } else {\n            x2 = v2[k2Offset - 1] + 1;\n          }\n\n          y2 = x2 - k2;\n\n          while (x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {\n            x2++;\n            y2++;\n          }\n\n          v2[k2Offset] = x2;\n\n          if (x2 > text1Length) {\n            // Ran off the left of the graph.\n            k2end += 2;\n          } else if (y2 > text2Length) {\n            // Ran off the top of the graph.\n            k2start += 2;\n          } else if (!front) {\n            k1Offset = vOffset + delta - k2;\n\n            if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n              x1 = v1[k1Offset];\n              y1 = vOffset + x1 - k1Offset; // Mirror x2 onto top-left coordinate system.\n\n              x2 = text1Length - x2;\n\n              if (x1 >= x2) {\n                // Overlap detected.\n                return this.diffBisectSplit(text1, text2, x1, y1, deadline);\n              }\n            }\n          }\n        }\n      } // Diff took too long and hit the deadline or\n      // number of diffs equals number of characters, no commonality at all.\n\n\n      return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n    };\n    /**\n     * Given the location of the 'middle snake', split the diff in two parts\n     * and recurse.\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {number} x Index of split point in text1.\n     * @param {number} y Index of split point in text2.\n     * @param {number} deadline Time at which to bail if not yet complete.\n     * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n     * @private\n     */\n\n\n    DiffMatchPatch.prototype.diffBisectSplit = function (text1, text2, x, y, deadline) {\n      var text1a, text1b, text2a, text2b, diffs, diffsb;\n      text1a = text1.substring(0, x);\n      text2a = text2.substring(0, y);\n      text1b = text1.substring(x);\n      text2b = text2.substring(y); // Compute both diffs serially.\n\n      diffs = this.DiffMain(text1a, text2a, false, deadline);\n      diffsb = this.DiffMain(text1b, text2b, false, deadline);\n      return diffs.concat(diffsb);\n    };\n    /**\n     * Reduce the number of edits by eliminating semantically trivial equalities.\n     * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n     */\n\n\n    DiffMatchPatch.prototype.diffCleanupSemantic = function (diffs) {\n      var changes, equalities, equalitiesLength, lastequality, pointer, lengthInsertions2, lengthDeletions2, lengthInsertions1, lengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n      changes = false;\n      equalities = []; // Stack of indices where equalities are found.\n\n      equalitiesLength = 0; // Keeping our own length var is faster in JS.\n\n      /** @type {?string} */\n\n      lastequality = null; // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\n      pointer = 0; // Index of current position.\n      // Number of characters that changed prior to the equality.\n\n      lengthInsertions1 = 0;\n      lengthDeletions1 = 0; // Number of characters that changed after the equality.\n\n      lengthInsertions2 = 0;\n      lengthDeletions2 = 0;\n\n      while (pointer < diffs.length) {\n        if (diffs[pointer][0] === DIFF_EQUAL) {\n          // Equality found.\n          equalities[equalitiesLength++] = pointer;\n          lengthInsertions1 = lengthInsertions2;\n          lengthDeletions1 = lengthDeletions2;\n          lengthInsertions2 = 0;\n          lengthDeletions2 = 0;\n          lastequality = diffs[pointer][1];\n        } else {\n          // An insertion or deletion.\n          if (diffs[pointer][0] === DIFF_INSERT) {\n            lengthInsertions2 += diffs[pointer][1].length;\n          } else {\n            lengthDeletions2 += diffs[pointer][1].length;\n          } // Eliminate an equality that is smaller or equal to the edits on both\n          // sides of it.\n\n\n          if (lastequality && lastequality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastequality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {\n            // Duplicate record.\n            diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]); // Change second copy to insert.\n\n            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT; // Throw away the equality we just deleted.\n\n            equalitiesLength--; // Throw away the previous equality (it needs to be reevaluated).\n\n            equalitiesLength--;\n            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1; // Reset the counters.\n\n            lengthInsertions1 = 0;\n            lengthDeletions1 = 0;\n            lengthInsertions2 = 0;\n            lengthDeletions2 = 0;\n            lastequality = null;\n            changes = true;\n          }\n        }\n\n        pointer++;\n      } // Normalize the diff.\n\n\n      if (changes) {\n        this.diffCleanupMerge(diffs);\n      } // Find any overlaps between deletions and insertions.\n      // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n      //   -> <del>abc</del>xxx<ins>def</ins>\n      // e.g: <del>xxxabc</del><ins>defxxx</ins>\n      //   -> <ins>def</ins>xxx<del>abc</del>\n      // Only extract an overlap if it is as big as the edit ahead or behind it.\n\n\n      pointer = 1;\n\n      while (pointer < diffs.length) {\n        if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n          deletion = diffs[pointer - 1][1];\n          insertion = diffs[pointer][1];\n          overlapLength1 = this.diffCommonOverlap(deletion, insertion);\n          overlapLength2 = this.diffCommonOverlap(insertion, deletion);\n\n          if (overlapLength1 >= overlapLength2) {\n            if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {\n              // Overlap found.  Insert an equality and trim the surrounding edits.\n              diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]);\n              diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);\n              diffs[pointer + 1][1] = insertion.substring(overlapLength1);\n              pointer++;\n            }\n          } else {\n            if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {\n              // Reverse overlap found.\n              // Insert an equality and swap and trim the surrounding edits.\n              diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]);\n              diffs[pointer - 1][0] = DIFF_INSERT;\n              diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);\n              diffs[pointer + 1][0] = DIFF_DELETE;\n              diffs[pointer + 1][1] = deletion.substring(overlapLength2);\n              pointer++;\n            }\n          }\n\n          pointer++;\n        }\n\n        pointer++;\n      }\n    };\n    /**\n     * Determine if the suffix of one string is the prefix of another.\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @return {number} The number of characters common to the end of the first\n     *     string and the start of the second string.\n     * @private\n     */\n\n\n    DiffMatchPatch.prototype.diffCommonOverlap = function (text1, text2) {\n      var text1Length, text2Length, textLength, best, length, pattern, found; // Cache the text lengths to prevent multiple calls.\n\n      text1Length = text1.length;\n      text2Length = text2.length; // Eliminate the null case.\n\n      if (text1Length === 0 || text2Length === 0) {\n        return 0;\n      } // Truncate the longer string.\n\n\n      if (text1Length > text2Length) {\n        text1 = text1.substring(text1Length - text2Length);\n      } else if (text1Length < text2Length) {\n        text2 = text2.substring(0, text1Length);\n      }\n\n      textLength = Math.min(text1Length, text2Length); // Quick check for the worst case.\n\n      if (text1 === text2) {\n        return textLength;\n      } // Start by looking for a single character match\n      // and increase length until no match is found.\n      // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\n\n      best = 0;\n      length = 1;\n\n      while (true) {\n        pattern = text1.substring(textLength - length);\n        found = text2.indexOf(pattern);\n\n        if (found === -1) {\n          return best;\n        }\n\n        length += found;\n\n        if (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {\n          best = length;\n          length++;\n        }\n      }\n    };\n    /**\n     * Split two texts into an array of strings.  Reduce the texts to a string of\n     * hashes where each Unicode character represents one line.\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n     *     An object containing the encoded text1, the encoded text2 and\n     *     the array of unique strings.\n     *     The zeroth element of the array of unique strings is intentionally blank.\n     * @private\n     */\n\n\n    DiffMatchPatch.prototype.diffLinesToChars = function (text1, text2) {\n      var lineArray, lineHash, chars1, chars2;\n      lineArray = []; // E.g. lineArray[4] === 'Hello\\n'\n\n      lineHash = {}; // E.g. lineHash['Hello\\n'] === 4\n      // '\\x00' is a valid character, but various debuggers don't like it.\n      // So we'll insert a junk entry to avoid generating a null character.\n\n      lineArray[0] = '';\n      /**\n       * Split a text into an array of strings.  Reduce the texts to a string of\n       * hashes where each Unicode character represents one line.\n       * Modifies linearray and linehash through being a closure.\n       * @param {string} text String to encode.\n       * @return {string} Encoded string.\n       * @private\n       */\n\n      function diffLinesToCharsMunge(text) {\n        var chars = ''; // Walk the text, pulling out a substring for each line.\n        // text.split('\\n') would would temporarily double our memory footprint.\n        // Modifying text would create many large strings to garbage collect.\n\n        var lineStart = 0;\n        var lineEnd = -1; // Keeping our own length variable is faster than looking it up.\n\n        var lineArrayLength = lineArray.length;\n\n        while (lineEnd < text.length - 1) {\n          lineEnd = text.indexOf('\\n', lineStart);\n\n          if (lineEnd === -1) {\n            lineEnd = text.length - 1;\n          }\n\n          var line = text.substring(lineStart, lineEnd + 1);\n          lineStart = lineEnd + 1;\n\n          if (hasOwn.call(lineHash, line)) {\n            chars += String.fromCharCode(lineHash[line]);\n          } else {\n            chars += String.fromCharCode(lineArrayLength);\n            lineHash[line] = lineArrayLength;\n            lineArray[lineArrayLength++] = line;\n          }\n        }\n\n        return chars;\n      }\n\n      chars1 = diffLinesToCharsMunge(text1);\n      chars2 = diffLinesToCharsMunge(text2);\n      return {\n        chars1: chars1,\n        chars2: chars2,\n        lineArray: lineArray\n      };\n    };\n    /**\n     * Rehydrate the text in a diff from a string of line hashes to real lines of\n     * text.\n     * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n     * @param {!Array.<string>} lineArray Array of unique strings.\n     * @private\n     */\n\n\n    DiffMatchPatch.prototype.diffCharsToLines = function (diffs, lineArray) {\n      var x, chars, text, y;\n\n      for (x = 0; x < diffs.length; x++) {\n        chars = diffs[x][1];\n        text = [];\n\n        for (y = 0; y < chars.length; y++) {\n          text[y] = lineArray[chars.charCodeAt(y)];\n        }\n\n        diffs[x][1] = text.join('');\n      }\n    };\n    /**\n     * Reorder and merge like edit sections.  Merge equalities.\n     * Any edit section can move as long as it doesn't cross an equality.\n     * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n     */\n\n\n    DiffMatchPatch.prototype.diffCleanupMerge = function (diffs) {\n      var pointer, countDelete, countInsert, textInsert, textDelete, commonlength, changes, diffPointer, position;\n      diffs.push([DIFF_EQUAL, '']); // Add a dummy entry at the end.\n\n      pointer = 0;\n      countDelete = 0;\n      countInsert = 0;\n      textDelete = '';\n      textInsert = '';\n\n      while (pointer < diffs.length) {\n        switch (diffs[pointer][0]) {\n          case DIFF_INSERT:\n            countInsert++;\n            textInsert += diffs[pointer][1];\n            pointer++;\n            break;\n\n          case DIFF_DELETE:\n            countDelete++;\n            textDelete += diffs[pointer][1];\n            pointer++;\n            break;\n\n          case DIFF_EQUAL:\n            // Upon reaching an equality, check for prior redundancies.\n            if (countDelete + countInsert > 1) {\n              if (countDelete !== 0 && countInsert !== 0) {\n                // Factor out any common prefixes.\n                commonlength = this.diffCommonPrefix(textInsert, textDelete);\n\n                if (commonlength !== 0) {\n                  if (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL) {\n                    diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);\n                  } else {\n                    diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]);\n                    pointer++;\n                  }\n\n                  textInsert = textInsert.substring(commonlength);\n                  textDelete = textDelete.substring(commonlength);\n                } // Factor out any common suffixies.\n\n\n                commonlength = this.diffCommonSuffix(textInsert, textDelete);\n\n                if (commonlength !== 0) {\n                  diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];\n                  textInsert = textInsert.substring(0, textInsert.length - commonlength);\n                  textDelete = textDelete.substring(0, textDelete.length - commonlength);\n                }\n              } // Delete the offending records and add the merged ones.\n\n\n              if (countDelete === 0) {\n                diffs.splice(pointer - countInsert, countDelete + countInsert, [DIFF_INSERT, textInsert]);\n              } else if (countInsert === 0) {\n                diffs.splice(pointer - countDelete, countDelete + countInsert, [DIFF_DELETE, textDelete]);\n              } else {\n                diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert, [DIFF_DELETE, textDelete], [DIFF_INSERT, textInsert]);\n              }\n\n              pointer = pointer - countDelete - countInsert + (countDelete ? 1 : 0) + (countInsert ? 1 : 0) + 1;\n            } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n              // Merge this equality with the previous one.\n              diffs[pointer - 1][1] += diffs[pointer][1];\n              diffs.splice(pointer, 1);\n            } else {\n              pointer++;\n            }\n\n            countInsert = 0;\n            countDelete = 0;\n            textDelete = '';\n            textInsert = '';\n            break;\n        }\n      }\n\n      if (diffs[diffs.length - 1][1] === '') {\n        diffs.pop(); // Remove the dummy entry at the end.\n      } // Second pass: look for single edits surrounded on both sides by equalities\n      // which can be shifted sideways to eliminate an equality.\n      // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\n\n      changes = false;\n      pointer = 1; // Intentionally ignore the first and last element (don't need checking).\n\n      while (pointer < diffs.length - 1) {\n        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n          diffPointer = diffs[pointer][1];\n          position = diffPointer.substring(diffPointer.length - diffs[pointer - 1][1].length); // This is a single edit surrounded by equalities.\n\n          if (position === diffs[pointer - 1][1]) {\n            // Shift the edit over the previous equality.\n            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n            diffs.splice(pointer - 1, 1);\n            changes = true;\n          } else if (diffPointer.substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {\n            // Shift the edit over the next equality.\n            diffs[pointer - 1][1] += diffs[pointer + 1][1];\n            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n            diffs.splice(pointer + 1, 1);\n            changes = true;\n          }\n        }\n\n        pointer++;\n      } // If shifts were made, the diff needs reordering and another shift sweep.\n\n\n      if (changes) {\n        this.diffCleanupMerge(diffs);\n      }\n    };\n\n    return function (o, n) {\n      var diff, output, text;\n      diff = new DiffMatchPatch();\n      output = diff.DiffMain(o, n);\n      diff.diffCleanupEfficiency(output);\n      text = diff.diffPrettyHtml(output);\n      return text;\n    };\n  }();\n\n})();\n\n\n//# sourceURL=webpack://wirejs-events/./node_modules/qunit/qunit/qunit.js?");

/***/ }),

/***/ "./tests/index.js":
/*!************************!*\
  !*** ./tests/index.js ***!
  \************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst QUnit = __webpack_require__(/*! qunit */ \"./node_modules/qunit/qunit/qunit.js\");\n\nlet fixture = document.createElement('div');\ndocument.body.appendChild(fixture);\n\nconst { on, once, onready, upon } = __webpack_require__(/*! ../lib */ \"./lib/index.js\");\n\nQUnit.test(\"on() : subscribers are called exactly once per fire()\", function (assert) {\n\tvar o = {};\n\tvar s1 = 0;\n\tvar s2 = 0;\n\n\ton(o, 'action').then(function () { s1++; });\n\ton(o, 'action').then(function () { s2++; });\n\ton(o, 'action').fire()\n\n\tassert.ok(s1 >= 1, \"first subscriber notified at least once\");\n\tassert.ok(s1 <= 1, \"first subscriber noticed only once\");\n\tassert.ok(s2 >= 1, \"second subscriber notified at least once\");\n\tassert.ok(s2 <= 1, \"second subscriber noticed only once\");\n\n\ton(o, 'action').fire();\n\tassert.ok(s1 >= 2, \"first subscriber was notified at least once on a subsequent fire()\");\n\tassert.ok(s1 <= 2, \"first subscriber was notified only once on a subsequent fire()\");\n\tassert.ok(s2 >= 2, \"second subscriber was notified at least once on a subsequent fire()\");\n\tassert.ok(s2 <= 2, \"second subscriber was notified only once on a subsequent fire()\");\n\n});\n\nQUnit.test(\"once() : single-fire events subscribers are called exactly once\", function (assert) {\n\tvar o = {};\n\tvar s1 = 0;\n\tvar s2 = 0;\n\n\tonce(o, 'action').then(function () { s1++; }, true);\n\tonce(o, 'action').then(function () { s2++; }, true);\n\tonce(o, 'action').fire()\n\n\tassert.equal(s1, 1, \"first subscriber notified exactly once\");\n\tassert.equal(s2, 1, \"second subscriber notified exactly once\");\n\n\tonce(o, 'action').fire();\n\tassert.equal(s1, 1, \"first subscriber was [correctly] not re-notified on a subsequent fire()\");\n\tassert.equal(s2, 1, \"second subscriber was [correctly] not re-notified on a subsequent fire()\");\n\n});\n\nQUnit.test(\"on() with immediate callback passes parameters\", function(assert) {\n\tvar o = {};\n\tvar a = null;\n\tvar b = null;\n\tvar c = null;\n\n\ton(o, 'action').then(function(_a, _b, _c) { a = _a; b = _b; c = _c; });\n\ton(o, 'action').fire(1,2,3);\n\n\tassert.ok(a === 1 && b === 2 && c === 3, \"all parameters were received by the subscriber\");\n});\n\nQUnit.test(\"on() with delayed callback passes parameters\", async function(assert) {\n\tvar o = {};\n\tvar a = null;\n\tvar b = null;\n\tvar c = null;\n\n\ton(o, 'action').then(function(_a, _b, _c) { a = _a; b = _b; c = _c; });\n\n\treturn new Promise(resolve => {\n\t\tsetTimeout(function() {\n\t\t\ton(o, 'action').fire(1,2,3);\n\t\t\tassert.ok(a === 1 && b === 2 && c === 3, \"all parameters were received by the subscriber\");\n\t\t\tresolve();\n\t\t}, 50);\n\t})\n});\n\nQUnit.test(\"on().intercept(interceptor) stops an event\", function (assert) {\n\tvar o = {};\n\tvar subscriberCalled = 0;\n\tvar interceptorCalled = 0;\n\n\ton(o, 'action').then(function () { subscriberCalled++; });\n\ton(o, 'action').intercept(function (evt) { interceptorCalled++; });\n\ton(o, 'action').fire();\n\n\tassert.equal(interceptorCalled, 1, \"the interceptor was called\");\n\tassert.equal(subscriberCalled, 0, \"the subscriber was not called\");\n});\n\nQUnit.test(\"on().intercept(interceptor) passes a resume()able event [proxy] to the interceptor\", function (assert) {\n\tvar o = {};\n\tvar subscriberCalled = 0;\n\tvar interceptorCalled = 0;\n\n\ton(o, 'action').then(function () { subscriberCalled = subscriberCalled * 2; });\n\ton(o, 'action').intercept(function (evt) { interceptorCalled = 1; subscriberCalled = 1; evt.resume(); });\n\ton(o, 'action').fire();\n\n\tassert.equal(interceptorCalled, 1, \"the interceptor was called\");\n\tassert.equal(subscriberCalled, 2, \"the subscriber called, and the interceptor was called first\");\n});\n\nQUnit.test(\"on().intercept(interceptor) succeeds with multiple true-returning intercetpors\", function (assert) {\n\tvar o = {};\n\tvar subscriberCalled = 0;\n\tvar interceptorCalled = 0;\n\n\ton(o, 'action').then(function () { subscriberCalled = subscriberCalled * 2; });\n\ton(o, 'action').intercept(function (evt) { interceptorCalled++; subscriberCalled++; evt.resume(); });\n\ton(o, 'action').intercept(function (evt) { interceptorCalled++; subscriberCalled++; evt.resume(); });\n\ton(o, 'action').fire();\n\n\tassert.equal(interceptorCalled, 2, \"both interceptors were called\");\n\tassert.equal(subscriberCalled, 4, \"the subscriber called, and both interceptors were called first\");\n});\n\nQUnit.test(\"on().intercept(interceptor) stops entirely on the first non-resuming interceptor\", function (assert) {\n\tvar o = {};\n\tvar subscriberCalled = 0;\n\tvar interceptorCalled = 0;\n\n\ton(o, 'action').then(function () { subscriberCalled++; });\n\ton(o, 'action').intercept(function (evt) { interceptorCalled++; });\n\ton(o, 'action').intercept(function (evt) { interceptorCalled++; evt.resume(); });\n\ton(o, 'action').fire();\n\n\tassert.equal(interceptorCalled, 1, \"only one interceptor was called\");\n\tassert.equal(subscriberCalled, 0, \"the subscriber was not called\");\n});\n\nQUnit.test(\"onready() operates like a single-fire event\", function (assert) {\n\tvar o = {};\n\tvar s1 = 0;\n\tvar s2 = 0;\n\n\tonready(o).then(function () { s1++; });\n\tonready(o).then(function () { s2++; });\n\tonready(o).fire();\n\n\tassert.ok(s1 == 1, \"first subscriber notified exactly once\");\n\tassert.ok(s2 == 1, \"second subscriber notified exactly once\");\n\n\tonready(o).fire();\n\tassert.ok(s1 == 1, \"first subscriber was [correctly] not re-notified on a subsequent fire()\");\n\tassert.ok(s2 == 1, \"second subscriber was [correctly] not re-notified on a subsequent fire()\");\n\n});\n\nQUnit.test(\"upon() performs callback immediately when possible\", function (assert) {\n\tvar r = false;\n\tupon(function () { return true; }, function () { r = true; });\n\tassert.ok(r, \"immediately performed callback for a test that always returns true\");\n});\n\nQUnit.test(\"upon() doesn't prematurely perform callback on delayed test-conditions\", function (assert) {\n\tvar t = false;\n\tvar r = false;\n\tsetTimeout(function () { t = true; }, 1000);\n\tupon(function () { return t; }, function () { r = true; });\n\tassert.ok(r === false, \"didn't prematurely perform callback\");\n});\n\nQUnit.test(\"upon() performs callback 'soon' after a delayed test-condition is true\", async function (assert) {\n\treturn new Promise(resolve => {\n\t\tvar startTime = (new Date()).getTime();\n\t\tvar endTime = 0;\n\t\tsetTimeout(function () { endTime = (new Date()).getTime(); }, 200);\n\t\n\t\tupon(function () { return endTime > startTime; }, function () {\n\t\t\tvar fireTime = (new Date()).getTime();\n\t\t\tassert.ok(true, \"callback was called\");\n\t\t\tassert.ok(fireTime - endTime < 100, \"less than 100 ms passed between state change and callback\");\n\t\t\tresolve();\n\t\t});\n\t})\n});\n\n\n//# sourceURL=webpack://wirejs-events/./tests/index.js?");

/***/ }),

/***/ "./tests/www.js":
/*!**********************!*\
  !*** ./tests/www.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const QUnit = __webpack_require__(/*! qunit */ \"./node_modules/qunit/qunit/qunit.js\");\nQUnit.start();\n__webpack_require__(/*! ./index.js */ \"./tests/index.js\");\n\n//# sourceURL=webpack://wirejs-events/./tests/www.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./lib/index.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./tests/www.js");
/******/ 	
/******/ })()
;